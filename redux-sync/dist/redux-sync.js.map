{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///redux-sync.js","webpack:///webpack/bootstrap c723f20f8d943aabbc9f","webpack:///./src/index.js","webpack:///./~/jsondiffpatch/src/contexts/context.js","webpack:///./~/jsondiffpatch/src/contexts/diff.js","webpack:///./~/jsondiffpatch/src/contexts/patch.js","webpack:///./~/jsondiffpatch/src/contexts/reverse.js","webpack:///./~/jsondiffpatch/public/external/diff_match_patch_uncompressed.js","webpack:///./~/jsondiffpatch/src/pipe.js","webpack:///./src/store.js","webpack:///./~/json-stringify-safe/stringify.js","webpack:///./~/jsondiffpatch/public/external ^\\.\\/.*$","webpack:///./~/jsondiffpatch/src/date-reviver.js","webpack:///./~/jsondiffpatch/src/diffpatcher.js","webpack:///./~/jsondiffpatch/src/filters/arrays.js","webpack:///./~/jsondiffpatch/src/filters/dates.js","webpack:///./~/jsondiffpatch/src/filters/lcs.js","webpack:///./~/jsondiffpatch/src/filters/nested.js","webpack:///./~/jsondiffpatch/src/filters/texts.js","webpack:///./~/jsondiffpatch/src/filters/trivial.js","webpack:///./~/jsondiffpatch/src/processor.js","webpack:///./~/object-path/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","syncStore","undefined","_store","_store2","Pipe","Context","prototype","setResult","result","hasResult","exit","exiting","switchTo","next","pipe","nextPipe","push","child","name","parent","childName","options","children","length","nextAfterChildren","dateReviver","DiffContext","left","right","cloneDiffValues","clone","JSON","parse","stringify","apply","arguments","PatchContext","delta","ReverseContext","diff_match_patch","Diff_Timeout","Diff_EditCost","Match_Threshold","Match_Distance","Patch_DeleteThreshold","Patch_Margin","Match_MaxBits","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","Diff","diff_main","text1","text2","opt_checklines","opt_deadline","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","substring","diff_commonSuffix","commonsuffix","diffs","diff_compute_","unshift","diff_cleanupMerge","longtext","shorttext","i","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","a","diff_linesToChars_","linearray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","splice","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","x","front","k1start","k1end","k2start","k2end","d","k1","x1","k1_offset","y1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","diff_linesToCharsMunge_","text","chars","lineStart","lineEnd","lineArrayLength","lineArray","line","lineHash","hasOwnProperty","String","fromCharCode","chars1","chars2","charCodeAt","join","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","diff_halfMatchI_","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","dmp","suffixLength","hm1","hm2","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length","diff_cleanupSemanticScore_","one","two","score","match","punctuation","whitespace","linebreak","blanklineEnd","blanklineStart","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","diff_xIndex","loc","last_chars1","last_chars2","diff_prettyHtml","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","op","data","replace","diff_text1","diff_text2","diff_levenshtein","levenshtein","insertions","deletions","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","match_bitapScore_","e","accuracy","proximity","abs","s","match_alphabet_","score_threshold","best_loc","lastIndexOf","matchmask","bin_min","bin_mid","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","patch","start2","length1","padding","prefix","suffix","start1","length2","patch_make","opt_b","opt_c","patches","patch_obj","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","diff_type","diff_text","patch_deepCopy","patchesCopy","patchCopy","slice","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","start_loc","expected_loc","end_loc","index2","index1","mod","paddingLength","extraLength","patch_size","bigpatch","precontext","empty","shift","postcontext","patch_toText","patch_fromText","textline","textPointer","patchHeader","sign","toString","coords1","coords2","filters","process","input","processor","debug","context","index","filter","log","filterName","resultCheck","msg","console","append","prepend","list","names","after","params","before","clear","shouldHaveResult","should","error","noResult","customOptions","_extends","defaultOptions","assign","env","isIframe","window","createStore","reducer","initialState","store","creationState","getState","creationPatch","diffpatcher","diff","sendMessage","type","INIT","state","dispatch","action","stateBefore","stateAfter","_patch","_objectPath2","get","connection","connections","addEventListener","_ref","source","origin","_JSON$parse","trigger","SYNC","replaceReducer","_jsonStringifySafe2","scope","postMessage","target","key","_jsonStringifySafe","_objectPath","_diffpatcher","DiffPatcher","create","replacer","spaces","cycleReplacer","serializer","stack","keys","thisPos","Infinity","getSerialize","webpackContext","req","webpackContextResolve","map","./diff_match_patch_uncompressed","./diff_match_patch_uncompressed.js","resolve","parts","exec","UTC","Processor","trivial","nested","arrays","dates","texts","collectChildrenDiffFilter","diffFilter","objectsDiffFilter","collectChildrenPatchFilter","patchFilter","collectChildrenReverseFilter","reverseFilter","reverse","unpatch","arraysHaveMatchByRef","array1","array2","len1","len2","val1","val2","matchItems","value1","value2","objectHash","matchByPosition","hash1","hash2","hashCache1","hashCache2","lcs","ARRAY_MOVE","isArray","arrayIndexOf","array","item","leftIsArray","matchContext","commonHead","commonTail","_t","trimmed1","trimmed2","seq","removedItems","indices1","detectMove","includeValueOnMove","removedItemsLength","indexOnArray2","indices2","isMove","removeItemIndex1","compare","numerically","b","numericallyBy","toRemove","toInsert","toModify","sort","indexDiff","removedValue","toInsertLength","toModifyLength","modification","newName","substr","reverseArrayDeltaIndex","itemDelta","reverseIndex","deltaIndex","deltaItem","moveFromIndex","moveToIndex","deleteIndex","defaultMatch","lengthMatrix","matrix","backtrack","sequence","subsequence","leftType","propertyFilter","TEXT_DIFF","DEFAULT_MIN_LENGTH","cachedDiffPatch","getDiffMatchPatch","required","instance","dmpModuleName","err","diff_match_patch_not_found","txt1","txt2","textPatchFailed","minLength","textDiff","diffMatchPatch","textDeltaReverse","l","lines","lineTmp","lineHeader","lineAdd","lineRemove","header","headerRegex","rightType","rightIsArray","selfOptions","pipes","lastPipe","lastContext","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","isEmpty","isString","_hasOwnProperty","toStr","isNumber","isObject","isBoolean","getKey","intKey","set","path","doNotReplace","currentPath","oldVal","del","objectPath","reduce","proxy","prop","bind","has","ensureExists","insert","at","arr","coalesce","paths","defaultValue","len"],"mappings":"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","file":"redux-sync.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxSync\"] = factory();\n\telse\n\t\troot[\"ReduxSync\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReduxSync\"] = factory();\n\telse\n\t\troot[\"ReduxSync\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = exports.syncStore = undefined;\n\t\n\tvar _store = __webpack_require__(7);\n\t\n\tvar _store2 = _interopRequireDefault(_store);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.syncStore = _store2.default; /**\n\t                                      * # Index\n\t                                      *\n\t                                      *\n\t                                      */\n\t\n\texports.default = _store2.default;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\tvar Pipe = __webpack_require__(6).Pipe;\n\t\n\tvar Context = function Context(){\n\t};\n\t\n\tContext.prototype.setResult = function(result) {\n\t\tthis.result = result;\n\t\tthis.hasResult = true;\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.exit = function() {\n\t\tthis.exiting = true;\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.switchTo = function(next, pipe) {\n\t\tif (typeof next === 'string' || next instanceof Pipe) {\n\t\t\tthis.nextPipe = next;\n\t\t} else {\n\t\t\tthis.next = next;\n\t\t\tif (pipe) {\n\t\t\t\tthis.nextPipe = pipe;\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t};\n\t\n\tContext.prototype.push = function(child, name) {\n\t\tchild.parent = this;\n\t\tif (typeof name !== 'undefined') {\n\t\t\tchild.childName = name;\n\t\t}\n\t\tchild.root = this.root || this;\n\t\tchild.options = child.options || this.options;\n\t\tif (!this.children) {\n\t\t\tthis.children = [child];\n\t\t\tthis.nextAfterChildren = this.next || null;\n\t\t\tthis.next = child;\n\t\t} else {\n\t\t\tthis.children[this.children.length - 1].next = child;\n\t\t\tthis.children.push(child);\n\t\t}\n\t\tchild.next = this;\n\t\treturn this;\n\t};\n\t\n\texports.Context = Context;\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(1).Context;\n\tvar dateReviver = __webpack_require__(10);\n\t\n\tvar DiffContext = function DiffContext(left, right) {\n\t  this.left = left;\n\t  this.right = right;\n\t  this.pipe = 'diff';\n\t};\n\t\n\tDiffContext.prototype = new Context();\n\t\n\tDiffContext.prototype.setResult = function(result) {\n\t  if (this.options.cloneDiffValues) {\n\t    var clone = typeof this.options.cloneDiffValues === 'function' ?\n\t      this.options.cloneDiffValues : function(value) {\n\t        return JSON.parse(JSON.stringify(value), dateReviver);\n\t      };\n\t    if (typeof result[0] === 'object') {\n\t      result[0] = clone(result[0]);\n\t    }\n\t    if (typeof result[1] === 'object') {\n\t      result[1] = clone(result[1]);\n\t    }\n\t  }\n\t  return Context.prototype.setResult.apply(this, arguments);\n\t};\n\t\n\texports.DiffContext = DiffContext;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(1).Context;\n\t\n\tvar PatchContext = function PatchContext(left, delta) {\n\t  this.left = left;\n\t  this.delta = delta;\n\t  this.pipe = 'patch';\n\t};\n\t\n\tPatchContext.prototype = new Context();\n\t\n\texports.PatchContext = PatchContext;\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Context = __webpack_require__(1).Context;\n\t\n\tvar ReverseContext = function ReverseContext(delta) {\n\t  this.delta = delta;\n\t  this.pipe = 'reverse';\n\t};\n\t\n\tReverseContext.prototype = new Context();\n\t\n\texports.ReverseContext = ReverseContext;\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Diff Match and Patch\n\t *\n\t * Copyright 2006 Google Inc.\n\t * http://code.google.com/p/google-diff-match-patch/\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *   http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * @fileoverview Computes the difference between two texts to create a patch.\n\t * Applies the patch onto another text, allowing for errors.\n\t * @author fraser@google.com (Neil Fraser)\n\t */\n\t\n\t/**\n\t * Class containing the diff, match and patch methods.\n\t * @constructor\n\t */\n\tfunction diff_match_patch() {\n\t\n\t  // Defaults.\n\t  // Redefine these in your program to override the defaults.\n\t\n\t  // Number of seconds to map a diff before giving up (0 for infinity).\n\t  this.Diff_Timeout = 1.0;\n\t  // Cost of an empty edit operation in terms of edit characters.\n\t  this.Diff_EditCost = 4;\n\t  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n\t  this.Match_Threshold = 0.5;\n\t  // How far to search for a match (0 = exact location, 1000+ = broad match).\n\t  // A match this many characters away from the expected location will add\n\t  // 1.0 to the score (0.0 is a perfect match).\n\t  this.Match_Distance = 1000;\n\t  // When deleting a large block of text (over ~64 characters), how close does\n\t  // the contents have to match the expected contents. (0.0 = perfection,\n\t  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n\t  // end points of a delete need to match.\n\t  this.Patch_DeleteThreshold = 0.5;\n\t  // Chunk size for context length.\n\t  this.Patch_Margin = 4;\n\t\n\t  // The number of bits in an int.\n\t  this.Match_MaxBits = 32;\n\t}\n\t\n\t\n\t//  DIFF FUNCTIONS\n\t\n\t\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1;\n\tvar DIFF_INSERT = 1;\n\tvar DIFF_EQUAL = 0;\n\t\n\t/** @typedef {!Array.<number|string>} */\n\tdiff_match_patch.Diff;\n\t\n\t\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @param {number} opt_deadline Optional time when the diff should be complete\n\t *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n\t *     instead.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t */\n\tdiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n\t    opt_deadline) {\n\t  // Set a deadline by which time the diff must be complete.\n\t  if (typeof opt_deadline == 'undefined') {\n\t    if (this.Diff_Timeout <= 0) {\n\t      opt_deadline = Number.MAX_VALUE;\n\t    } else {\n\t      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n\t    }\n\t  }\n\t  var deadline = opt_deadline;\n\t\n\t  // Check for null inputs.\n\t  if (text1 == null || text2 == null) {\n\t    throw new Error('Null input. (diff_main)');\n\t  }\n\t\n\t  // Check for equality (speedup).\n\t  if (text1 == text2) {\n\t    if (text1) {\n\t      return [[DIFF_EQUAL, text1]];\n\t    }\n\t    return [];\n\t  }\n\t\n\t  if (typeof opt_checklines == 'undefined') {\n\t    opt_checklines = true;\n\t  }\n\t  var checklines = opt_checklines;\n\t\n\t  // Trim off common prefix (speedup).\n\t  var commonlength = this.diff_commonPrefix(text1, text2);\n\t  var commonprefix = text1.substring(0, commonlength);\n\t  text1 = text1.substring(commonlength);\n\t  text2 = text2.substring(commonlength);\n\t\n\t  // Trim off common suffix (speedup).\n\t  commonlength = this.diff_commonSuffix(text1, text2);\n\t  var commonsuffix = text1.substring(text1.length - commonlength);\n\t  text1 = text1.substring(0, text1.length - commonlength);\n\t  text2 = text2.substring(0, text2.length - commonlength);\n\t\n\t  // Compute the diff on the middle block.\n\t  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\t\n\t  // Restore the prefix and suffix.\n\t  if (commonprefix) {\n\t    diffs.unshift([DIFF_EQUAL, commonprefix]);\n\t  }\n\t  if (commonsuffix) {\n\t    diffs.push([DIFF_EQUAL, commonsuffix]);\n\t  }\n\t  this.diff_cleanupMerge(diffs);\n\t  return diffs;\n\t};\n\t\n\t\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n\t    deadline) {\n\t  var diffs;\n\t\n\t  if (!text1) {\n\t    // Just add some text (speedup).\n\t    return [[DIFF_INSERT, text2]];\n\t  }\n\t\n\t  if (!text2) {\n\t    // Just delete some text (speedup).\n\t    return [[DIFF_DELETE, text1]];\n\t  }\n\t\n\t  var longtext = text1.length > text2.length ? text1 : text2;\n\t  var shorttext = text1.length > text2.length ? text2 : text1;\n\t  var i = longtext.indexOf(shorttext);\n\t  if (i != -1) {\n\t    // Shorter text is inside the longer text (speedup).\n\t    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n\t             [DIFF_EQUAL, shorttext],\n\t             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n\t    // Swap insertions for deletions if diff is reversed.\n\t    if (text1.length > text2.length) {\n\t      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n\t    }\n\t    return diffs;\n\t  }\n\t\n\t  if (shorttext.length == 1) {\n\t    // Single character string.\n\t    // After the previous speedup, the character can't be an equality.\n\t    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t  }\n\t  longtext = shorttext = null;  // Garbage collect.\n\t\n\t  // Check to see if the problem can be split in two.\n\t  var hm = this.diff_halfMatch_(text1, text2);\n\t  if (hm) {\n\t    // A half-match was found, sort out the return data.\n\t    var text1_a = hm[0];\n\t    var text1_b = hm[1];\n\t    var text2_a = hm[2];\n\t    var text2_b = hm[3];\n\t    var mid_common = hm[4];\n\t    // Send both pairs off for separate processing.\n\t    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n\t    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n\t    // Merge the results.\n\t    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n\t  }\n\t\n\t  if (checklines && text1.length > 100 && text2.length > 100) {\n\t    return this.diff_lineMode_(text1, text2, deadline);\n\t  }\n\t\n\t  return this.diff_bisect_(text1, text2, deadline);\n\t};\n\t\n\t\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n\t  // Scan the text on a line-by-line basis first.\n\t  var a = this.diff_linesToChars_(text1, text2);\n\t  text1 = /** @type {string} */(a[0]);\n\t  text2 = /** @type {string} */(a[1]);\n\t  var linearray = /** @type {!Array.<string>} */(a[2]);\n\t\n\t  var diffs = this.diff_bisect_(text1, text2, deadline);\n\t\n\t  // Convert the diff back to original text.\n\t  this.diff_charsToLines_(diffs, linearray);\n\t  // Eliminate freak matches (e.g. blank lines)\n\t  this.diff_cleanupSemantic(diffs);\n\t\n\t  // Rediff any replacement blocks, this time character-by-character.\n\t  // Add a dummy entry at the end.\n\t  diffs.push([DIFF_EQUAL, '']);\n\t  var pointer = 0;\n\t  var count_delete = 0;\n\t  var count_insert = 0;\n\t  var text_delete = '';\n\t  var text_insert = '';\n\t  while (pointer < diffs.length) {\n\t    switch (diffs[pointer][0]) {\n\t      case DIFF_INSERT:\n\t        count_insert++;\n\t        text_insert += diffs[pointer][1];\n\t        break;\n\t      case DIFF_DELETE:\n\t        count_delete++;\n\t        text_delete += diffs[pointer][1];\n\t        break;\n\t      case DIFF_EQUAL:\n\t        // Upon reaching an equality, check for prior redundancies.\n\t        if (count_delete >= 1 && count_insert >= 1) {\n\t          // Delete the offending records and add the merged ones.\n\t          var a = this.diff_main(text_delete, text_insert, false, deadline);\n\t          diffs.splice(pointer - count_delete - count_insert,\n\t                       count_delete + count_insert);\n\t          pointer = pointer - count_delete - count_insert;\n\t          for (var j = a.length - 1; j >= 0; j--) {\n\t            diffs.splice(pointer, 0, a[j]);\n\t          }\n\t          pointer = pointer + a.length;\n\t        }\n\t        count_insert = 0;\n\t        count_delete = 0;\n\t        text_delete = '';\n\t        text_insert = '';\n\t        break;\n\t    }\n\t    pointer++;\n\t  }\n\t  diffs.pop();  // Remove the dummy entry at the end.\n\t\n\t  return diffs;\n\t};\n\t\n\t\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n\t  // Cache the text lengths to prevent multiple calls.\n\t  var text1_length = text1.length;\n\t  var text2_length = text2.length;\n\t  var max_d = Math.ceil((text1_length + text2_length) / 2);\n\t  var v_offset = max_d;\n\t  var v_length = 2 * max_d;\n\t  var v1 = new Array(v_length);\n\t  var v2 = new Array(v_length);\n\t  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t  // integers and undefined.\n\t  for (var x = 0; x < v_length; x++) {\n\t    v1[x] = -1;\n\t    v2[x] = -1;\n\t  }\n\t  v1[v_offset + 1] = 0;\n\t  v2[v_offset + 1] = 0;\n\t  var delta = text1_length - text2_length;\n\t  // If the total number of characters is odd, then the front path will collide\n\t  // with the reverse path.\n\t  var front = (delta % 2 != 0);\n\t  // Offsets for start and end of k loop.\n\t  // Prevents mapping of space beyond the grid.\n\t  var k1start = 0;\n\t  var k1end = 0;\n\t  var k2start = 0;\n\t  var k2end = 0;\n\t  for (var d = 0; d < max_d; d++) {\n\t    // Bail out if deadline is reached.\n\t    if ((new Date()).getTime() > deadline) {\n\t      break;\n\t    }\n\t\n\t    // Walk the front path one step.\n\t    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n\t      var k1_offset = v_offset + k1;\n\t      var x1;\n\t      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n\t        x1 = v1[k1_offset + 1];\n\t      } else {\n\t        x1 = v1[k1_offset - 1] + 1;\n\t      }\n\t      var y1 = x1 - k1;\n\t      while (x1 < text1_length && y1 < text2_length &&\n\t             text1.charAt(x1) == text2.charAt(y1)) {\n\t        x1++;\n\t        y1++;\n\t      }\n\t      v1[k1_offset] = x1;\n\t      if (x1 > text1_length) {\n\t        // Ran off the right of the graph.\n\t        k1end += 2;\n\t      } else if (y1 > text2_length) {\n\t        // Ran off the bottom of the graph.\n\t        k1start += 2;\n\t      } else if (front) {\n\t        var k2_offset = v_offset + delta - k1;\n\t        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n\t          // Mirror x2 onto top-left coordinate system.\n\t          var x2 = text1_length - v2[k2_offset];\n\t          if (x1 >= x2) {\n\t            // Overlap detected.\n\t            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Walk the reverse path one step.\n\t    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n\t      var k2_offset = v_offset + k2;\n\t      var x2;\n\t      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n\t        x2 = v2[k2_offset + 1];\n\t      } else {\n\t        x2 = v2[k2_offset - 1] + 1;\n\t      }\n\t      var y2 = x2 - k2;\n\t      while (x2 < text1_length && y2 < text2_length &&\n\t             text1.charAt(text1_length - x2 - 1) ==\n\t             text2.charAt(text2_length - y2 - 1)) {\n\t        x2++;\n\t        y2++;\n\t      }\n\t      v2[k2_offset] = x2;\n\t      if (x2 > text1_length) {\n\t        // Ran off the left of the graph.\n\t        k2end += 2;\n\t      } else if (y2 > text2_length) {\n\t        // Ran off the top of the graph.\n\t        k2start += 2;\n\t      } else if (!front) {\n\t        var k1_offset = v_offset + delta - k2;\n\t        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n\t          var x1 = v1[k1_offset];\n\t          var y1 = v_offset + x1 - k1_offset;\n\t          // Mirror x2 onto top-left coordinate system.\n\t          x2 = text1_length - x2;\n\t          if (x1 >= x2) {\n\t            // Overlap detected.\n\t            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // Diff took too long and hit the deadline or\n\t  // number of diffs equals number of characters, no commonality at all.\n\t  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n\t};\n\t\n\t\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n\t    deadline) {\n\t  var text1a = text1.substring(0, x);\n\t  var text2a = text2.substring(0, y);\n\t  var text1b = text1.substring(x);\n\t  var text2b = text2.substring(y);\n\t\n\t  // Compute both diffs serially.\n\t  var diffs = this.diff_main(text1a, text2a, false, deadline);\n\t  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\t\n\t  return diffs.concat(diffsb);\n\t};\n\t\n\t\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {!Array.<string|!Array.<string>>} Three element Array, containing the\n\t *     encoded text1, the encoded text2 and the array of unique strings.  The\n\t *     zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n\t  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n\t  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\t\n\t  // '\\x00' is a valid character, but various debuggers don't like it.\n\t  // So we'll insert a junk entry to avoid generating a null character.\n\t  lineArray[0] = '';\n\t\n\t  /**\n\t   * Split a text into an array of strings.  Reduce the texts to a string of\n\t   * hashes where each Unicode character represents one line.\n\t   * Modifies linearray and linehash through being a closure.\n\t   * @param {string} text String to encode.\n\t   * @return {string} Encoded string.\n\t   * @private\n\t   */\n\t  function diff_linesToCharsMunge_(text) {\n\t    var chars = '';\n\t    // Walk the text, pulling out a substring for each line.\n\t    // text.split('\\n') would would temporarily double our memory footprint.\n\t    // Modifying text would create many large strings to garbage collect.\n\t    var lineStart = 0;\n\t    var lineEnd = -1;\n\t    // Keeping our own length variable is faster than looking it up.\n\t    var lineArrayLength = lineArray.length;\n\t    while (lineEnd < text.length - 1) {\n\t      lineEnd = text.indexOf('\\n', lineStart);\n\t      if (lineEnd == -1) {\n\t        lineEnd = text.length - 1;\n\t      }\n\t      var line = text.substring(lineStart, lineEnd + 1);\n\t      lineStart = lineEnd + 1;\n\t\n\t      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n\t          (lineHash[line] !== undefined)) {\n\t        chars += String.fromCharCode(lineHash[line]);\n\t      } else {\n\t        chars += String.fromCharCode(lineArrayLength);\n\t        lineHash[line] = lineArrayLength;\n\t        lineArray[lineArrayLength++] = line;\n\t      }\n\t    }\n\t    return chars;\n\t  }\n\t\n\t  var chars1 = diff_linesToCharsMunge_(text1);\n\t  var chars2 = diff_linesToCharsMunge_(text2);\n\t  return [chars1, chars2, lineArray];\n\t};\n\t\n\t\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    var chars = diffs[x][1];\n\t    var text = [];\n\t    for (var y = 0; y < chars.length; y++) {\n\t      text[y] = lineArray[chars.charCodeAt(y)];\n\t    }\n\t    diffs[x][1] = text.join('');\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tdiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n\t  // Quick check for common null cases.\n\t  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n\t    return 0;\n\t  }\n\t  // Binary search.\n\t  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t  var pointermin = 0;\n\t  var pointermax = Math.min(text1.length, text2.length);\n\t  var pointermid = pointermax;\n\t  var pointerstart = 0;\n\t  while (pointermin < pointermid) {\n\t    if (text1.substring(pointerstart, pointermid) ==\n\t        text2.substring(pointerstart, pointermid)) {\n\t      pointermin = pointermid;\n\t      pointerstart = pointermin;\n\t    } else {\n\t      pointermax = pointermid;\n\t    }\n\t    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t  }\n\t  return pointermid;\n\t};\n\t\n\t\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tdiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n\t  // Quick check for common null cases.\n\t  if (!text1 || !text2 ||\n\t      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n\t    return 0;\n\t  }\n\t  // Binary search.\n\t  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n\t  var pointermin = 0;\n\t  var pointermax = Math.min(text1.length, text2.length);\n\t  var pointermid = pointermax;\n\t  var pointerend = 0;\n\t  while (pointermin < pointermid) {\n\t    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n\t        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n\t      pointermin = pointermid;\n\t      pointerend = pointermin;\n\t    } else {\n\t      pointermax = pointermid;\n\t    }\n\t    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n\t  }\n\t  return pointermid;\n\t};\n\t\n\t\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n\t  // Cache the text lengths to prevent multiple calls.\n\t  var text1_length = text1.length;\n\t  var text2_length = text2.length;\n\t  // Eliminate the null case.\n\t  if (text1_length == 0 || text2_length == 0) {\n\t    return 0;\n\t  }\n\t  // Truncate the longer string.\n\t  if (text1_length > text2_length) {\n\t    text1 = text1.substring(text1_length - text2_length);\n\t  } else if (text1_length < text2_length) {\n\t    text2 = text2.substring(0, text1_length);\n\t  }\n\t  var text_length = Math.min(text1_length, text2_length);\n\t  // Quick check for the worst case.\n\t  if (text1 == text2) {\n\t    return text_length;\n\t  }\n\t\n\t  // Start by looking for a single character match\n\t  // and increase length until no match is found.\n\t  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n\t  var best = 0;\n\t  var length = 1;\n\t  while (true) {\n\t    var pattern = text1.substring(text_length - length);\n\t    var found = text2.indexOf(pattern);\n\t    if (found == -1) {\n\t      return best;\n\t    }\n\t    length += found;\n\t    if (found == 0 || text1.substring(text_length - length) ==\n\t        text2.substring(0, length)) {\n\t      best = length;\n\t      length++;\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n\t  if (this.Diff_Timeout <= 0) {\n\t    // Don't risk returning a non-optimal diff if we have unlimited time.\n\t    return null;\n\t  }\n\t  var longtext = text1.length > text2.length ? text1 : text2;\n\t  var shorttext = text1.length > text2.length ? text2 : text1;\n\t  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n\t    return null;  // Pointless.\n\t  }\n\t  var dmp = this;  // 'this' becomes 'window' in a closure.\n\t\n\t  /**\n\t   * Does a substring of shorttext exist within longtext such that the substring\n\t   * is at least half the length of longtext?\n\t   * Closure, but does not reference any external variables.\n\t   * @param {string} longtext Longer string.\n\t   * @param {string} shorttext Shorter string.\n\t   * @param {number} i Start index of quarter length substring within longtext.\n\t   * @return {Array.<string>} Five element Array, containing the prefix of\n\t   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t   *     of shorttext and the common middle.  Or null if there was no match.\n\t   * @private\n\t   */\n\t  function diff_halfMatchI_(longtext, shorttext, i) {\n\t    // Start with a 1/4 length substring at position i as a seed.\n\t    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n\t    var j = -1;\n\t    var best_common = '';\n\t    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n\t    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n\t      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n\t                                               shorttext.substring(j));\n\t      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n\t                                               shorttext.substring(0, j));\n\t      if (best_common.length < suffixLength + prefixLength) {\n\t        best_common = shorttext.substring(j - suffixLength, j) +\n\t            shorttext.substring(j, j + prefixLength);\n\t        best_longtext_a = longtext.substring(0, i - suffixLength);\n\t        best_longtext_b = longtext.substring(i + prefixLength);\n\t        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n\t        best_shorttext_b = shorttext.substring(j + prefixLength);\n\t      }\n\t    }\n\t    if (best_common.length * 2 >= longtext.length) {\n\t      return [best_longtext_a, best_longtext_b,\n\t              best_shorttext_a, best_shorttext_b, best_common];\n\t    } else {\n\t      return null;\n\t    }\n\t  }\n\t\n\t  // First check if the second quarter is the seed for a half-match.\n\t  var hm1 = diff_halfMatchI_(longtext, shorttext,\n\t                             Math.ceil(longtext.length / 4));\n\t  // Check again based on the third quarter.\n\t  var hm2 = diff_halfMatchI_(longtext, shorttext,\n\t                             Math.ceil(longtext.length / 2));\n\t  var hm;\n\t  if (!hm1 && !hm2) {\n\t    return null;\n\t  } else if (!hm2) {\n\t    hm = hm1;\n\t  } else if (!hm1) {\n\t    hm = hm2;\n\t  } else {\n\t    // Both matched.  Select the longest.\n\t    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n\t  }\n\t\n\t  // A half-match was found, sort out the return data.\n\t  var text1_a, text1_b, text2_a, text2_b;\n\t  if (text1.length > text2.length) {\n\t    text1_a = hm[0];\n\t    text1_b = hm[1];\n\t    text2_a = hm[2];\n\t    text2_b = hm[3];\n\t  } else {\n\t    text2_a = hm[0];\n\t    text2_b = hm[1];\n\t    text1_a = hm[2];\n\t    text1_b = hm[3];\n\t  }\n\t  var mid_common = hm[4];\n\t  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n\t};\n\t\n\t\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t */\n\tdiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n\t  var changes = false;\n\t  var equalities = [];  // Stack of indices where equalities are found.\n\t  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n\t  /** @type {?string} */\n\t  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]\n\t  var pointer = 0;  // Index of current position.\n\t  // Number of characters that changed prior to the equality.\n\t  var length_insertions1 = 0;\n\t  var length_deletions1 = 0;\n\t  // Number of characters that changed after the equality.\n\t  var length_insertions2 = 0;\n\t  var length_deletions2 = 0;\n\t  while (pointer < diffs.length) {\n\t    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n\t      equalities[equalitiesLength++] = pointer;\n\t      length_insertions1 = length_insertions2;\n\t      length_deletions1 = length_deletions2;\n\t      length_insertions2 = 0;\n\t      length_deletions2 = 0;\n\t      lastequality = /** @type {string} */(diffs[pointer][1]);\n\t    } else {  // An insertion or deletion.\n\t      if (diffs[pointer][0] == DIFF_INSERT) {\n\t        length_insertions2 += diffs[pointer][1].length;\n\t      } else {\n\t        length_deletions2 += diffs[pointer][1].length;\n\t      }\n\t      // Eliminate an equality that is smaller or equal to the edits on both\n\t      // sides of it.\n\t      if (lastequality !== null && (lastequality.length <=\n\t          Math.max(length_insertions1, length_deletions1)) &&\n\t          (lastequality.length <= Math.max(length_insertions2,\n\t                                           length_deletions2))) {\n\t        // Duplicate record.\n\t        diffs.splice(equalities[equalitiesLength - 1], 0,\n\t                     [DIFF_DELETE, lastequality]);\n\t        // Change second copy to insert.\n\t        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t        // Throw away the equality we just deleted.\n\t        equalitiesLength--;\n\t        // Throw away the previous equality (it needs to be reevaluated).\n\t        equalitiesLength--;\n\t        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n\t        length_insertions1 = 0;  // Reset the counters.\n\t        length_deletions1 = 0;\n\t        length_insertions2 = 0;\n\t        length_deletions2 = 0;\n\t        lastequality = null;\n\t        changes = true;\n\t      }\n\t    }\n\t    pointer++;\n\t  }\n\t\n\t  // Normalize the diff.\n\t  if (changes) {\n\t    this.diff_cleanupMerge(diffs);\n\t  }\n\t  this.diff_cleanupSemanticLossless(diffs);\n\t\n\t  // Find any overlaps between deletions and insertions.\n\t  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t  //   -> <del>abc</del>xxx<ins>def</ins>\n\t  // Only extract an overlap if it is as big as the edit ahead or behind it.\n\t  pointer = 1;\n\t  while (pointer < diffs.length) {\n\t    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n\t        diffs[pointer][0] == DIFF_INSERT) {\n\t      var deletion = /** @type {string} */(diffs[pointer - 1][1]);\n\t      var insertion = /** @type {string} */(diffs[pointer][1]);\n\t      var overlap_length = this.diff_commonOverlap_(deletion, insertion);\n\t      if (overlap_length >= deletion.length / 2 ||\n\t          overlap_length >= insertion.length / 2) {\n\t        // Overlap found.  Insert an equality and trim the surrounding edits.\n\t        diffs.splice(pointer, 0,\n\t            [DIFF_EQUAL, insertion.substring(0, overlap_length)]);\n\t        diffs[pointer - 1][1] =\n\t            deletion.substring(0, deletion.length - overlap_length);\n\t        diffs[pointer + 1][1] = insertion.substring(overlap_length);\n\t        pointer++;\n\t      }\n\t      pointer++;\n\t    }\n\t    pointer++;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Look for single edits surrounded on both sides by equalities\n\t * which can be shifted sideways to align the edit to a word boundary.\n\t * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t */\n\tdiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n\t  // Define some regex patterns for matching boundaries.\n\t  var punctuation = /[^a-zA-Z0-9]/;\n\t  var whitespace = /\\s/;\n\t  var linebreak = /[\\r\\n]/;\n\t  var blanklineEnd = /\\n\\r?\\n$/;\n\t  var blanklineStart = /^\\r?\\n\\r?\\n/;\n\t\n\t  /**\n\t   * Given two strings, compute a score representing whether the internal\n\t   * boundary falls on logical boundaries.\n\t   * Scores range from 5 (best) to 0 (worst).\n\t   * Closure, makes reference to regex patterns defined above.\n\t   * @param {string} one First string.\n\t   * @param {string} two Second string.\n\t   * @return {number} The score.\n\t   * @private\n\t   */\n\t  function diff_cleanupSemanticScore_(one, two) {\n\t    if (!one || !two) {\n\t      // Edges are the best.\n\t      return 5;\n\t    }\n\t\n\t    // Each port of this function behaves slightly differently due to\n\t    // subtle differences in each language's definition of things like\n\t    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n\t    // the choice has been made to use each language's native features\n\t    // rather than force total conformity.\n\t    var score = 0;\n\t    // One point for non-alphanumeric.\n\t    if (one.charAt(one.length - 1).match(punctuation) ||\n\t        two.charAt(0).match(punctuation)) {\n\t      score++;\n\t      // Two points for whitespace.\n\t      if (one.charAt(one.length - 1).match(whitespace) ||\n\t          two.charAt(0).match(whitespace)) {\n\t        score++;\n\t        // Three points for line breaks.\n\t        if (one.charAt(one.length - 1).match(linebreak) ||\n\t            two.charAt(0).match(linebreak)) {\n\t          score++;\n\t          // Four points for blank lines.\n\t          if (one.match(blanklineEnd) || two.match(blanklineStart)) {\n\t            score++;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return score;\n\t  }\n\t\n\t  var pointer = 1;\n\t  // Intentionally ignore the first and last element (don't need checking).\n\t  while (pointer < diffs.length - 1) {\n\t    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n\t        diffs[pointer + 1][0] == DIFF_EQUAL) {\n\t      // This is a single edit surrounded by equalities.\n\t      var equality1 = /** @type {string} */(diffs[pointer - 1][1]);\n\t      var edit = /** @type {string} */(diffs[pointer][1]);\n\t      var equality2 = /** @type {string} */(diffs[pointer + 1][1]);\n\t\n\t      // First, shift the edit as far left as possible.\n\t      var commonOffset = this.diff_commonSuffix(equality1, edit);\n\t      if (commonOffset) {\n\t        var commonString = edit.substring(edit.length - commonOffset);\n\t        equality1 = equality1.substring(0, equality1.length - commonOffset);\n\t        edit = commonString + edit.substring(0, edit.length - commonOffset);\n\t        equality2 = commonString + equality2;\n\t      }\n\t\n\t      // Second, step character by character right, looking for the best fit.\n\t      var bestEquality1 = equality1;\n\t      var bestEdit = edit;\n\t      var bestEquality2 = equality2;\n\t      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n\t          diff_cleanupSemanticScore_(edit, equality2);\n\t      while (edit.charAt(0) === equality2.charAt(0)) {\n\t        equality1 += edit.charAt(0);\n\t        edit = edit.substring(1) + equality2.charAt(0);\n\t        equality2 = equality2.substring(1);\n\t        var score = diff_cleanupSemanticScore_(equality1, edit) +\n\t            diff_cleanupSemanticScore_(edit, equality2);\n\t        // The >= encourages trailing rather than leading whitespace on edits.\n\t        if (score >= bestScore) {\n\t          bestScore = score;\n\t          bestEquality1 = equality1;\n\t          bestEdit = edit;\n\t          bestEquality2 = equality2;\n\t        }\n\t      }\n\t\n\t      if (diffs[pointer - 1][1] != bestEquality1) {\n\t        // We have an improvement, save it back to the diff.\n\t        if (bestEquality1) {\n\t          diffs[pointer - 1][1] = bestEquality1;\n\t        } else {\n\t          diffs.splice(pointer - 1, 1);\n\t          pointer--;\n\t        }\n\t        diffs[pointer][1] = bestEdit;\n\t        if (bestEquality2) {\n\t          diffs[pointer + 1][1] = bestEquality2;\n\t        } else {\n\t          diffs.splice(pointer + 1, 1);\n\t          pointer--;\n\t        }\n\t      }\n\t    }\n\t    pointer++;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t */\n\tdiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n\t  var changes = false;\n\t  var equalities = [];  // Stack of indices where equalities are found.\n\t  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n\t  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]\n\t  var pointer = 0;  // Index of current position.\n\t  // Is there an insertion operation before the last equality.\n\t  var pre_ins = false;\n\t  // Is there a deletion operation before the last equality.\n\t  var pre_del = false;\n\t  // Is there an insertion operation after the last equality.\n\t  var post_ins = false;\n\t  // Is there a deletion operation after the last equality.\n\t  var post_del = false;\n\t  while (pointer < diffs.length) {\n\t    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n\t      if (diffs[pointer][1].length < this.Diff_EditCost &&\n\t          (post_ins || post_del)) {\n\t        // Candidate found.\n\t        equalities[equalitiesLength++] = pointer;\n\t        pre_ins = post_ins;\n\t        pre_del = post_del;\n\t        lastequality = diffs[pointer][1];\n\t      } else {\n\t        // Not a candidate, and can never become one.\n\t        equalitiesLength = 0;\n\t        lastequality = '';\n\t      }\n\t      post_ins = post_del = false;\n\t    } else {  // An insertion or deletion.\n\t      if (diffs[pointer][0] == DIFF_DELETE) {\n\t        post_del = true;\n\t      } else {\n\t        post_ins = true;\n\t      }\n\t      /*\n\t       * Five types to be split:\n\t       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t       * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t       * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t       * <ins>A</del>X<ins>C</ins><del>D</del>\n\t       * <ins>A</ins><del>B</del>X<del>C</del>\n\t       */\n\t      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n\t                           ((lastequality.length < this.Diff_EditCost / 2) &&\n\t                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n\t        // Duplicate record.\n\t        diffs.splice(equalities[equalitiesLength - 1], 0,\n\t                     [DIFF_DELETE, lastequality]);\n\t        // Change second copy to insert.\n\t        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n\t        equalitiesLength--;  // Throw away the equality we just deleted;\n\t        lastequality = '';\n\t        if (pre_ins && pre_del) {\n\t          // No changes made which could affect previous entry, keep going.\n\t          post_ins = post_del = true;\n\t          equalitiesLength = 0;\n\t        } else {\n\t          equalitiesLength--;  // Throw away the previous equality.\n\t          pointer = equalitiesLength > 0 ?\n\t              equalities[equalitiesLength - 1] : -1;\n\t          post_ins = post_del = false;\n\t        }\n\t        changes = true;\n\t      }\n\t    }\n\t    pointer++;\n\t  }\n\t\n\t  if (changes) {\n\t    this.diff_cleanupMerge(diffs);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t */\n\tdiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n\t  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n\t  var pointer = 0;\n\t  var count_delete = 0;\n\t  var count_insert = 0;\n\t  var text_delete = '';\n\t  var text_insert = '';\n\t  var commonlength;\n\t  while (pointer < diffs.length) {\n\t    switch (diffs[pointer][0]) {\n\t      case DIFF_INSERT:\n\t        count_insert++;\n\t        text_insert += diffs[pointer][1];\n\t        pointer++;\n\t        break;\n\t      case DIFF_DELETE:\n\t        count_delete++;\n\t        text_delete += diffs[pointer][1];\n\t        pointer++;\n\t        break;\n\t      case DIFF_EQUAL:\n\t        // Upon reaching an equality, check for prior redundancies.\n\t        if (count_delete + count_insert > 1) {\n\t          if (count_delete !== 0 && count_insert !== 0) {\n\t            // Factor out any common prefixies.\n\t            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n\t            if (commonlength !== 0) {\n\t              if ((pointer - count_delete - count_insert) > 0 &&\n\t                  diffs[pointer - count_delete - count_insert - 1][0] ==\n\t                  DIFF_EQUAL) {\n\t                diffs[pointer - count_delete - count_insert - 1][1] +=\n\t                    text_insert.substring(0, commonlength);\n\t              } else {\n\t                diffs.splice(0, 0, [DIFF_EQUAL,\n\t                                    text_insert.substring(0, commonlength)]);\n\t                pointer++;\n\t              }\n\t              text_insert = text_insert.substring(commonlength);\n\t              text_delete = text_delete.substring(commonlength);\n\t            }\n\t            // Factor out any common suffixies.\n\t            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n\t            if (commonlength !== 0) {\n\t              diffs[pointer][1] = text_insert.substring(text_insert.length -\n\t                  commonlength) + diffs[pointer][1];\n\t              text_insert = text_insert.substring(0, text_insert.length -\n\t                  commonlength);\n\t              text_delete = text_delete.substring(0, text_delete.length -\n\t                  commonlength);\n\t            }\n\t          }\n\t          // Delete the offending records and add the merged ones.\n\t          if (count_delete === 0) {\n\t            diffs.splice(pointer - count_delete - count_insert,\n\t                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n\t          } else if (count_insert === 0) {\n\t            diffs.splice(pointer - count_delete - count_insert,\n\t                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n\t          } else {\n\t            diffs.splice(pointer - count_delete - count_insert,\n\t                count_delete + count_insert, [DIFF_DELETE, text_delete],\n\t                [DIFF_INSERT, text_insert]);\n\t          }\n\t          pointer = pointer - count_delete - count_insert +\n\t                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n\t        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n\t          // Merge this equality with the previous one.\n\t          diffs[pointer - 1][1] += diffs[pointer][1];\n\t          diffs.splice(pointer, 1);\n\t        } else {\n\t          pointer++;\n\t        }\n\t        count_insert = 0;\n\t        count_delete = 0;\n\t        text_delete = '';\n\t        text_insert = '';\n\t        break;\n\t    }\n\t  }\n\t  if (diffs[diffs.length - 1][1] === '') {\n\t    diffs.pop();  // Remove the dummy entry at the end.\n\t  }\n\t\n\t  // Second pass: look for single edits surrounded on both sides by equalities\n\t  // which can be shifted sideways to eliminate an equality.\n\t  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t  var changes = false;\n\t  pointer = 1;\n\t  // Intentionally ignore the first and last element (don't need checking).\n\t  while (pointer < diffs.length - 1) {\n\t    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n\t        diffs[pointer + 1][0] == DIFF_EQUAL) {\n\t      // This is a single edit surrounded by equalities.\n\t      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n\t          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n\t        // Shift the edit over the previous equality.\n\t        diffs[pointer][1] = diffs[pointer - 1][1] +\n\t            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n\t                                        diffs[pointer - 1][1].length);\n\t        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n\t        diffs.splice(pointer - 1, 1);\n\t        changes = true;\n\t      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n\t          diffs[pointer + 1][1]) {\n\t        // Shift the edit over the next equality.\n\t        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n\t        diffs[pointer][1] =\n\t            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n\t            diffs[pointer + 1][1];\n\t        diffs.splice(pointer + 1, 1);\n\t        changes = true;\n\t      }\n\t    }\n\t    pointer++;\n\t  }\n\t  // If shifts were made, the diff needs reordering and another shift sweep.\n\t  if (changes) {\n\t    this.diff_cleanupMerge(diffs);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * loc is a location in text1, compute and return the equivalent location in\n\t * text2.\n\t * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @param {number} loc Location within text1.\n\t * @return {number} Location within text2.\n\t */\n\tdiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n\t  var chars1 = 0;\n\t  var chars2 = 0;\n\t  var last_chars1 = 0;\n\t  var last_chars2 = 0;\n\t  var x;\n\t  for (x = 0; x < diffs.length; x++) {\n\t    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n\t      chars1 += diffs[x][1].length;\n\t    }\n\t    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n\t      chars2 += diffs[x][1].length;\n\t    }\n\t    if (chars1 > loc) {  // Overshot the location.\n\t      break;\n\t    }\n\t    last_chars1 = chars1;\n\t    last_chars2 = chars2;\n\t  }\n\t  // Was the location was deleted?\n\t  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n\t    return last_chars2;\n\t  }\n\t  // Add the remaining character length.\n\t  return last_chars2 + (loc - last_chars1);\n\t};\n\t\n\t\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @return {string} HTML representation.\n\t */\n\tdiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n\t  var html = [];\n\t  var i = 0;\n\t  var pattern_amp = /&/g;\n\t  var pattern_lt = /</g;\n\t  var pattern_gt = />/g;\n\t  var pattern_para = /\\n/g;\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    var op = diffs[x][0];    // Operation (insert, delete, equal)\n\t    var data = diffs[x][1];  // Text of change.\n\t    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n\t        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n\t    switch (op) {\n\t      case DIFF_INSERT:\n\t        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n\t        break;\n\t      case DIFF_DELETE:\n\t        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n\t        break;\n\t      case DIFF_EQUAL:\n\t        html[x] = '<span>' + text + '</span>';\n\t        break;\n\t    }\n\t    if (op !== DIFF_DELETE) {\n\t      i += data.length;\n\t    }\n\t  }\n\t  return html.join('');\n\t};\n\t\n\t\n\t/**\n\t * Compute and return the source text (all equalities and deletions).\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @return {string} Source text.\n\t */\n\tdiff_match_patch.prototype.diff_text1 = function(diffs) {\n\t  var text = [];\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    if (diffs[x][0] !== DIFF_INSERT) {\n\t      text[x] = diffs[x][1];\n\t    }\n\t  }\n\t  return text.join('');\n\t};\n\t\n\t\n\t/**\n\t * Compute and return the destination text (all equalities and insertions).\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @return {string} Destination text.\n\t */\n\tdiff_match_patch.prototype.diff_text2 = function(diffs) {\n\t  var text = [];\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    if (diffs[x][0] !== DIFF_DELETE) {\n\t      text[x] = diffs[x][1];\n\t    }\n\t  }\n\t  return text.join('');\n\t};\n\t\n\t\n\t/**\n\t * Compute the Levenshtein distance; the number of inserted, deleted or\n\t * substituted characters.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @return {number} Number of changes.\n\t */\n\tdiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n\t  var levenshtein = 0;\n\t  var insertions = 0;\n\t  var deletions = 0;\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    var op = diffs[x][0];\n\t    var data = diffs[x][1];\n\t    switch (op) {\n\t      case DIFF_INSERT:\n\t        insertions += data.length;\n\t        break;\n\t      case DIFF_DELETE:\n\t        deletions += data.length;\n\t        break;\n\t      case DIFF_EQUAL:\n\t        // A deletion and an insertion is one substitution.\n\t        levenshtein += Math.max(insertions, deletions);\n\t        insertions = 0;\n\t        deletions = 0;\n\t        break;\n\t    }\n\t  }\n\t  levenshtein += Math.max(insertions, deletions);\n\t  return levenshtein;\n\t};\n\t\n\t\n\t/**\n\t * Crush the diff into an encoded string which describes the operations\n\t * required to transform text1 into text2.\n\t * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n\t * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n\t * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n\t * @return {string} Delta text.\n\t */\n\tdiff_match_patch.prototype.diff_toDelta = function(diffs) {\n\t  var text = [];\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    switch (diffs[x][0]) {\n\t      case DIFF_INSERT:\n\t        text[x] = '+' + encodeURI(diffs[x][1]);\n\t        break;\n\t      case DIFF_DELETE:\n\t        text[x] = '-' + diffs[x][1].length;\n\t        break;\n\t      case DIFF_EQUAL:\n\t        text[x] = '=' + diffs[x][1].length;\n\t        break;\n\t    }\n\t  }\n\t  return text.join('\\t').replace(/%20/g, ' ');\n\t};\n\t\n\t\n\t/**\n\t * Given the original text1, and an encoded string which describes the\n\t * operations required to transform text1 into text2, compute the full diff.\n\t * @param {string} text1 Source string for the diff.\n\t * @param {string} delta Delta text.\n\t * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n\t * @throws {!Error} If invalid input.\n\t */\n\tdiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n\t  var diffs = [];\n\t  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n\t  var pointer = 0;  // Cursor in text1\n\t  var tokens = delta.split(/\\t/g);\n\t  for (var x = 0; x < tokens.length; x++) {\n\t    // Each token begins with a one character parameter which specifies the\n\t    // operation of this token (delete, insert, equality).\n\t    var param = tokens[x].substring(1);\n\t    switch (tokens[x].charAt(0)) {\n\t      case '+':\n\t        try {\n\t          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n\t        } catch (ex) {\n\t          // Malformed URI sequence.\n\t          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n\t        }\n\t        break;\n\t      case '-':\n\t        // Fall through.\n\t      case '=':\n\t        var n = parseInt(param, 10);\n\t        if (isNaN(n) || n < 0) {\n\t          throw new Error('Invalid number in diff_fromDelta: ' + param);\n\t        }\n\t        var text = text1.substring(pointer, pointer += n);\n\t        if (tokens[x].charAt(0) == '=') {\n\t          diffs[diffsLength++] = [DIFF_EQUAL, text];\n\t        } else {\n\t          diffs[diffsLength++] = [DIFF_DELETE, text];\n\t        }\n\t        break;\n\t      default:\n\t        // Blank tokens are ok (from a trailing \\t).\n\t        // Anything else is an error.\n\t        if (tokens[x]) {\n\t          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n\t                          tokens[x]);\n\t        }\n\t    }\n\t  }\n\t  if (pointer != text1.length) {\n\t    throw new Error('Delta length (' + pointer +\n\t        ') does not equal source text length (' + text1.length + ').');\n\t  }\n\t  return diffs;\n\t};\n\t\n\t\n\t//  MATCH FUNCTIONS\n\t\n\t\n\t/**\n\t * Locate the best instance of 'pattern' in 'text' near 'loc'.\n\t * @param {string} text The text to search.\n\t * @param {string} pattern The pattern to search for.\n\t * @param {number} loc The location to search around.\n\t * @return {number} Best match index or -1.\n\t */\n\tdiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n\t  // Check for null inputs.\n\t  if (text == null || pattern == null || loc == null) {\n\t    throw new Error('Null input. (match_main)');\n\t  }\n\t\n\t  loc = Math.max(0, Math.min(loc, text.length));\n\t  if (text == pattern) {\n\t    // Shortcut (potentially not guaranteed by the algorithm)\n\t    return 0;\n\t  } else if (!text.length) {\n\t    // Nothing to match.\n\t    return -1;\n\t  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n\t    // Perfect match at the perfect spot!  (Includes case of null pattern)\n\t    return loc;\n\t  } else {\n\t    // Do a fuzzy compare.\n\t    return this.match_bitap_(text, pattern, loc);\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n\t * Bitap algorithm.\n\t * @param {string} text The text to search.\n\t * @param {string} pattern The pattern to search for.\n\t * @param {number} loc The location to search around.\n\t * @return {number} Best match index or -1.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n\t  if (pattern.length > this.Match_MaxBits) {\n\t    throw new Error('Pattern too long for this browser.');\n\t  }\n\t\n\t  // Initialise the alphabet.\n\t  var s = this.match_alphabet_(pattern);\n\t\n\t  var dmp = this;  // 'this' becomes 'window' in a closure.\n\t\n\t  /**\n\t   * Compute and return the score for a match with e errors and x location.\n\t   * Accesses loc and pattern through being a closure.\n\t   * @param {number} e Number of errors in match.\n\t   * @param {number} x Location of match.\n\t   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n\t   * @private\n\t   */\n\t  function match_bitapScore_(e, x) {\n\t    var accuracy = e / pattern.length;\n\t    var proximity = Math.abs(loc - x);\n\t    if (!dmp.Match_Distance) {\n\t      // Dodge divide by zero error.\n\t      return proximity ? 1.0 : accuracy;\n\t    }\n\t    return accuracy + (proximity / dmp.Match_Distance);\n\t  }\n\t\n\t  // Highest score beyond which we give up.\n\t  var score_threshold = this.Match_Threshold;\n\t  // Is there a nearby exact match? (speedup)\n\t  var best_loc = text.indexOf(pattern, loc);\n\t  if (best_loc != -1) {\n\t    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n\t    // What about in the other direction? (speedup)\n\t    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n\t    if (best_loc != -1) {\n\t      score_threshold =\n\t          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n\t    }\n\t  }\n\t\n\t  // Initialise the bit arrays.\n\t  var matchmask = 1 << (pattern.length - 1);\n\t  best_loc = -1;\n\t\n\t  var bin_min, bin_mid;\n\t  var bin_max = pattern.length + text.length;\n\t  var last_rd;\n\t  for (var d = 0; d < pattern.length; d++) {\n\t    // Scan for the best match; each iteration allows for one more error.\n\t    // Run a binary search to determine how far from 'loc' we can stray at this\n\t    // error level.\n\t    bin_min = 0;\n\t    bin_mid = bin_max;\n\t    while (bin_min < bin_mid) {\n\t      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n\t        bin_min = bin_mid;\n\t      } else {\n\t        bin_max = bin_mid;\n\t      }\n\t      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n\t    }\n\t    // Use the result from this iteration as the maximum for the next.\n\t    bin_max = bin_mid;\n\t    var start = Math.max(1, loc - bin_mid + 1);\n\t    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\t\n\t    var rd = Array(finish + 2);\n\t    rd[finish + 1] = (1 << d) - 1;\n\t    for (var j = finish; j >= start; j--) {\n\t      // The alphabet (s) is a sparse hash, so the following line generates\n\t      // warnings.\n\t      var charMatch = s[text.charAt(j - 1)];\n\t      if (d === 0) {  // First pass: exact match.\n\t        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n\t      } else {  // Subsequent passes: fuzzy match.\n\t        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |\n\t                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n\t                last_rd[j + 1];\n\t      }\n\t      if (rd[j] & matchmask) {\n\t        var score = match_bitapScore_(d, j - 1);\n\t        // This match will almost certainly be better than any existing match.\n\t        // But check anyway.\n\t        if (score <= score_threshold) {\n\t          // Told you so.\n\t          score_threshold = score;\n\t          best_loc = j - 1;\n\t          if (best_loc > loc) {\n\t            // When passing loc, don't exceed our current distance from loc.\n\t            start = Math.max(1, 2 * loc - best_loc);\n\t          } else {\n\t            // Already passed loc, downhill from here on in.\n\t            break;\n\t          }\n\t        }\n\t      }\n\t    }\n\t    // No hope for a (better) match at greater error levels.\n\t    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n\t      break;\n\t    }\n\t    last_rd = rd;\n\t  }\n\t  return best_loc;\n\t};\n\t\n\t\n\t/**\n\t * Initialise the alphabet for the Bitap algorithm.\n\t * @param {string} pattern The text to encode.\n\t * @return {!Object} Hash of character locations.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n\t  var s = {};\n\t  for (var i = 0; i < pattern.length; i++) {\n\t    s[pattern.charAt(i)] = 0;\n\t  }\n\t  for (var i = 0; i < pattern.length; i++) {\n\t    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n\t  }\n\t  return s;\n\t};\n\t\n\t\n\t//  PATCH FUNCTIONS\n\t\n\t\n\t/**\n\t * Increase the context until it is unique,\n\t * but don't let the pattern expand beyond Match_MaxBits.\n\t * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n\t * @param {string} text Source text.\n\t * @private\n\t */\n\tdiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n\t  if (text.length == 0) {\n\t    return;\n\t  }\n\t  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n\t  var padding = 0;\n\t\n\t  // Look for the first and last matches of pattern in text.  If two different\n\t  // matches are found, increase the pattern length.\n\t  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n\t         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n\t         this.Patch_Margin) {\n\t    padding += this.Patch_Margin;\n\t    pattern = text.substring(patch.start2 - padding,\n\t                             patch.start2 + patch.length1 + padding);\n\t  }\n\t  // Add one chunk for good luck.\n\t  padding += this.Patch_Margin;\n\t\n\t  // Add the prefix.\n\t  var prefix = text.substring(patch.start2 - padding, patch.start2);\n\t  if (prefix) {\n\t    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n\t  }\n\t  // Add the suffix.\n\t  var suffix = text.substring(patch.start2 + patch.length1,\n\t                              patch.start2 + patch.length1 + padding);\n\t  if (suffix) {\n\t    patch.diffs.push([DIFF_EQUAL, suffix]);\n\t  }\n\t\n\t  // Roll back the start points.\n\t  patch.start1 -= prefix.length;\n\t  patch.start2 -= prefix.length;\n\t  // Extend the lengths.\n\t  patch.length1 += prefix.length + suffix.length;\n\t  patch.length2 += prefix.length + suffix.length;\n\t};\n\t\n\t\n\t/**\n\t * Compute a list of patches to turn text1 into text2.\n\t * Use diffs if provided, otherwise compute it ourselves.\n\t * There are four ways to call this function, depending on what data is\n\t * available to the caller:\n\t * Method 1:\n\t * a = text1, b = text2\n\t * Method 2:\n\t * a = diffs\n\t * Method 3 (optimal):\n\t * a = text1, b = diffs\n\t * Method 4 (deprecated, use method 3):\n\t * a = text1, b = text2, c = diffs\n\t *\n\t * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n\t * Array of diff tuples for text1 to text2 (method 2).\n\t * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n\t * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n\t * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n\t * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n\t */\n\tdiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n\t  var text1, diffs;\n\t  if (typeof a == 'string' && typeof opt_b == 'string' &&\n\t      typeof opt_c == 'undefined') {\n\t    // Method 1: text1, text2\n\t    // Compute diffs from text1 and text2.\n\t    text1 = /** @type {string} */(a);\n\t    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n\t    if (diffs.length > 2) {\n\t      this.diff_cleanupSemantic(diffs);\n\t      this.diff_cleanupEfficiency(diffs);\n\t    }\n\t  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n\t      typeof opt_c == 'undefined') {\n\t    // Method 2: diffs\n\t    // Compute text1 from diffs.\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n\t    text1 = this.diff_text1(diffs);\n\t  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n\t      typeof opt_c == 'undefined') {\n\t    // Method 3: text1, diffs\n\t    text1 = /** @type {string} */(a);\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n\t  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n\t      opt_c && typeof opt_c == 'object') {\n\t    // Method 4: text1, text2, diffs\n\t    // text2 is not used.\n\t    text1 = /** @type {string} */(a);\n\t    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n\t  } else {\n\t    throw new Error('Unknown call format to patch_make.');\n\t  }\n\t\n\t  if (diffs.length === 0) {\n\t    return [];  // Get rid of the null case.\n\t  }\n\t  var patches = [];\n\t  var patch = new diff_match_patch.patch_obj();\n\t  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n\t  var char_count1 = 0;  // Number of characters into the text1 string.\n\t  var char_count2 = 0;  // Number of characters into the text2 string.\n\t  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n\t  // text2 (postpatch_text).  We recreate the patches one by one to determine\n\t  // context info.\n\t  var prepatch_text = text1;\n\t  var postpatch_text = text1;\n\t  for (var x = 0; x < diffs.length; x++) {\n\t    var diff_type = diffs[x][0];\n\t    var diff_text = diffs[x][1];\n\t\n\t    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n\t      // A new patch starts here.\n\t      patch.start1 = char_count1;\n\t      patch.start2 = char_count2;\n\t    }\n\t\n\t    switch (diff_type) {\n\t      case DIFF_INSERT:\n\t        patch.diffs[patchDiffLength++] = diffs[x];\n\t        patch.length2 += diff_text.length;\n\t        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n\t                         postpatch_text.substring(char_count2);\n\t        break;\n\t      case DIFF_DELETE:\n\t        patch.length1 += diff_text.length;\n\t        patch.diffs[patchDiffLength++] = diffs[x];\n\t        postpatch_text = postpatch_text.substring(0, char_count2) +\n\t                         postpatch_text.substring(char_count2 +\n\t                             diff_text.length);\n\t        break;\n\t      case DIFF_EQUAL:\n\t        if (diff_text.length <= 2 * this.Patch_Margin &&\n\t            patchDiffLength && diffs.length != x + 1) {\n\t          // Small equality inside a patch.\n\t          patch.diffs[patchDiffLength++] = diffs[x];\n\t          patch.length1 += diff_text.length;\n\t          patch.length2 += diff_text.length;\n\t        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n\t          // Time for a new patch.\n\t          if (patchDiffLength) {\n\t            this.patch_addContext_(patch, prepatch_text);\n\t            patches.push(patch);\n\t            patch = new diff_match_patch.patch_obj();\n\t            patchDiffLength = 0;\n\t            // Unlike Unidiff, our patch lists have a rolling context.\n\t            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n\t            // Update prepatch text & pos to reflect the application of the\n\t            // just completed patch.\n\t            prepatch_text = postpatch_text;\n\t            char_count1 = char_count2;\n\t          }\n\t        }\n\t        break;\n\t    }\n\t\n\t    // Update the current character count.\n\t    if (diff_type !== DIFF_INSERT) {\n\t      char_count1 += diff_text.length;\n\t    }\n\t    if (diff_type !== DIFF_DELETE) {\n\t      char_count2 += diff_text.length;\n\t    }\n\t  }\n\t  // Pick up the leftover patch if not empty.\n\t  if (patchDiffLength) {\n\t    this.patch_addContext_(patch, prepatch_text);\n\t    patches.push(patch);\n\t  }\n\t\n\t  return patches;\n\t};\n\t\n\t\n\t/**\n\t * Given an array of patches, return another array that is identical.\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n\t */\n\tdiff_match_patch.prototype.patch_deepCopy = function(patches) {\n\t  // Making deep copies is hard in JavaScript.\n\t  var patchesCopy = [];\n\t  for (var x = 0; x < patches.length; x++) {\n\t    var patch = patches[x];\n\t    var patchCopy = new diff_match_patch.patch_obj();\n\t    patchCopy.diffs = [];\n\t    for (var y = 0; y < patch.diffs.length; y++) {\n\t      patchCopy.diffs[y] = patch.diffs[y].slice();\n\t    }\n\t    patchCopy.start1 = patch.start1;\n\t    patchCopy.start2 = patch.start2;\n\t    patchCopy.length1 = patch.length1;\n\t    patchCopy.length2 = patch.length2;\n\t    patchesCopy[x] = patchCopy;\n\t  }\n\t  return patchesCopy;\n\t};\n\t\n\t\n\t/**\n\t * Merge a set of patches onto the text.  Return a patched text, as well\n\t * as a list of true/false values indicating which patches were applied.\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n\t * @param {string} text Old text.\n\t * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n\t *      new text and an array of boolean values.\n\t */\n\tdiff_match_patch.prototype.patch_apply = function(patches, text) {\n\t  if (patches.length == 0) {\n\t    return [text, []];\n\t  }\n\t\n\t  // Deep copy the patches so that no changes are made to originals.\n\t  patches = this.patch_deepCopy(patches);\n\t\n\t  var nullPadding = this.patch_addPadding(patches);\n\t  text = nullPadding + text + nullPadding;\n\t\n\t  this.patch_splitMax(patches);\n\t  // delta keeps track of the offset between the expected and actual location\n\t  // of the previous patch.  If there are patches expected at positions 10 and\n\t  // 20, but the first patch was found at 12, delta is 2 and the second patch\n\t  // has an effective expected position of 22.\n\t  var delta = 0;\n\t  var results = [];\n\t  for (var x = 0; x < patches.length; x++) {\n\t    var expected_loc = patches[x].start2 + delta;\n\t    var text1 = this.diff_text1(patches[x].diffs);\n\t    var start_loc;\n\t    var end_loc = -1;\n\t    if (text1.length > this.Match_MaxBits) {\n\t      // patch_splitMax will only provide an oversized pattern in the case of\n\t      // a monster delete.\n\t      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n\t                                  expected_loc);\n\t      if (start_loc != -1) {\n\t        end_loc = this.match_main(text,\n\t            text1.substring(text1.length - this.Match_MaxBits),\n\t            expected_loc + text1.length - this.Match_MaxBits);\n\t        if (end_loc == -1 || start_loc >= end_loc) {\n\t          // Can't find valid trailing context.  Drop this patch.\n\t          start_loc = -1;\n\t        }\n\t      }\n\t    } else {\n\t      start_loc = this.match_main(text, text1, expected_loc);\n\t    }\n\t    if (start_loc == -1) {\n\t      // No match found.  :(\n\t      results[x] = false;\n\t      // Subtract the delta for this failed patch from subsequent patches.\n\t      delta -= patches[x].length2 - patches[x].length1;\n\t    } else {\n\t      // Found a match.  :)\n\t      results[x] = true;\n\t      delta = start_loc - expected_loc;\n\t      var text2;\n\t      if (end_loc == -1) {\n\t        text2 = text.substring(start_loc, start_loc + text1.length);\n\t      } else {\n\t        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n\t      }\n\t      if (text1 == text2) {\n\t        // Perfect match, just shove the replacement text in.\n\t        text = text.substring(0, start_loc) +\n\t               this.diff_text2(patches[x].diffs) +\n\t               text.substring(start_loc + text1.length);\n\t      } else {\n\t        // Imperfect match.  Run a diff to get a framework of equivalent\n\t        // indices.\n\t        var diffs = this.diff_main(text1, text2, false);\n\t        if (text1.length > this.Match_MaxBits &&\n\t            this.diff_levenshtein(diffs) / text1.length >\n\t            this.Patch_DeleteThreshold) {\n\t          // The end points match, but the content is unacceptably bad.\n\t          results[x] = false;\n\t        } else {\n\t          this.diff_cleanupSemanticLossless(diffs);\n\t          var index1 = 0;\n\t          var index2;\n\t          for (var y = 0; y < patches[x].diffs.length; y++) {\n\t            var mod = patches[x].diffs[y];\n\t            if (mod[0] !== DIFF_EQUAL) {\n\t              index2 = this.diff_xIndex(diffs, index1);\n\t            }\n\t            if (mod[0] === DIFF_INSERT) {  // Insertion\n\t              text = text.substring(0, start_loc + index2) + mod[1] +\n\t                     text.substring(start_loc + index2);\n\t            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n\t              text = text.substring(0, start_loc + index2) +\n\t                     text.substring(start_loc + this.diff_xIndex(diffs,\n\t                         index1 + mod[1].length));\n\t            }\n\t            if (mod[0] !== DIFF_DELETE) {\n\t              index1 += mod[1].length;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  // Strip the padding off.\n\t  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n\t  return [text, results];\n\t};\n\t\n\t\n\t/**\n\t * Add some padding on text start and end so that edges can match something.\n\t * Intended to be called only from within patch_apply.\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n\t * @return {string} The padding string added to each side.\n\t */\n\tdiff_match_patch.prototype.patch_addPadding = function(patches) {\n\t  var paddingLength = this.Patch_Margin;\n\t  var nullPadding = '';\n\t  for (var x = 1; x <= paddingLength; x++) {\n\t    nullPadding += String.fromCharCode(x);\n\t  }\n\t\n\t  // Bump all the patches forward.\n\t  for (var x = 0; x < patches.length; x++) {\n\t    patches[x].start1 += paddingLength;\n\t    patches[x].start2 += paddingLength;\n\t  }\n\t\n\t  // Add some padding on start of first diff.\n\t  var patch = patches[0];\n\t  var diffs = patch.diffs;\n\t  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n\t    // Add nullPadding equality.\n\t    diffs.unshift([DIFF_EQUAL, nullPadding]);\n\t    patch.start1 -= paddingLength;  // Should be 0.\n\t    patch.start2 -= paddingLength;  // Should be 0.\n\t    patch.length1 += paddingLength;\n\t    patch.length2 += paddingLength;\n\t  } else if (paddingLength > diffs[0][1].length) {\n\t    // Grow first equality.\n\t    var extraLength = paddingLength - diffs[0][1].length;\n\t    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n\t    patch.start1 -= extraLength;\n\t    patch.start2 -= extraLength;\n\t    patch.length1 += extraLength;\n\t    patch.length2 += extraLength;\n\t  }\n\t\n\t  // Add some padding on end of last diff.\n\t  patch = patches[patches.length - 1];\n\t  diffs = patch.diffs;\n\t  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n\t    // Add nullPadding equality.\n\t    diffs.push([DIFF_EQUAL, nullPadding]);\n\t    patch.length1 += paddingLength;\n\t    patch.length2 += paddingLength;\n\t  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n\t    // Grow last equality.\n\t    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n\t    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n\t    patch.length1 += extraLength;\n\t    patch.length2 += extraLength;\n\t  }\n\t\n\t  return nullPadding;\n\t};\n\t\n\t\n\t/**\n\t * Look through the patches and break up any which are longer than the maximum\n\t * limit of the match algorithm.\n\t * Intended to be called only from within patch_apply.\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n\t */\n\tdiff_match_patch.prototype.patch_splitMax = function(patches) {\n\t  var patch_size = this.Match_MaxBits;\n\t  for (var x = 0; x < patches.length; x++) {\n\t    if (patches[x].length1 > patch_size) {\n\t      var bigpatch = patches[x];\n\t      // Remove the big old patch.\n\t      patches.splice(x--, 1);\n\t      var start1 = bigpatch.start1;\n\t      var start2 = bigpatch.start2;\n\t      var precontext = '';\n\t      while (bigpatch.diffs.length !== 0) {\n\t        // Create one of several smaller patches.\n\t        var patch = new diff_match_patch.patch_obj();\n\t        var empty = true;\n\t        patch.start1 = start1 - precontext.length;\n\t        patch.start2 = start2 - precontext.length;\n\t        if (precontext !== '') {\n\t          patch.length1 = patch.length2 = precontext.length;\n\t          patch.diffs.push([DIFF_EQUAL, precontext]);\n\t        }\n\t        while (bigpatch.diffs.length !== 0 &&\n\t               patch.length1 < patch_size - this.Patch_Margin) {\n\t          var diff_type = bigpatch.diffs[0][0];\n\t          var diff_text = bigpatch.diffs[0][1];\n\t          if (diff_type === DIFF_INSERT) {\n\t            // Insertions are harmless.\n\t            patch.length2 += diff_text.length;\n\t            start2 += diff_text.length;\n\t            patch.diffs.push(bigpatch.diffs.shift());\n\t            empty = false;\n\t          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n\t                     patch.diffs[0][0] == DIFF_EQUAL &&\n\t                     diff_text.length > 2 * patch_size) {\n\t            // This is a large deletion.  Let it pass in one chunk.\n\t            patch.length1 += diff_text.length;\n\t            start1 += diff_text.length;\n\t            empty = false;\n\t            patch.diffs.push([diff_type, diff_text]);\n\t            bigpatch.diffs.shift();\n\t          } else {\n\t            // Deletion or equality.  Only take as much as we can stomach.\n\t            diff_text = diff_text.substring(0,\n\t                patch_size - patch.length1 - this.Patch_Margin);\n\t            patch.length1 += diff_text.length;\n\t            start1 += diff_text.length;\n\t            if (diff_type === DIFF_EQUAL) {\n\t              patch.length2 += diff_text.length;\n\t              start2 += diff_text.length;\n\t            } else {\n\t              empty = false;\n\t            }\n\t            patch.diffs.push([diff_type, diff_text]);\n\t            if (diff_text == bigpatch.diffs[0][1]) {\n\t              bigpatch.diffs.shift();\n\t            } else {\n\t              bigpatch.diffs[0][1] =\n\t                  bigpatch.diffs[0][1].substring(diff_text.length);\n\t            }\n\t          }\n\t        }\n\t        // Compute the head context for the next patch.\n\t        precontext = this.diff_text2(patch.diffs);\n\t        precontext =\n\t            precontext.substring(precontext.length - this.Patch_Margin);\n\t        // Append the end context for this patch.\n\t        var postcontext = this.diff_text1(bigpatch.diffs)\n\t                              .substring(0, this.Patch_Margin);\n\t        if (postcontext !== '') {\n\t          patch.length1 += postcontext.length;\n\t          patch.length2 += postcontext.length;\n\t          if (patch.diffs.length !== 0 &&\n\t              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n\t            patch.diffs[patch.diffs.length - 1][1] += postcontext;\n\t          } else {\n\t            patch.diffs.push([DIFF_EQUAL, postcontext]);\n\t          }\n\t        }\n\t        if (!empty) {\n\t          patches.splice(++x, 0, patch);\n\t        }\n\t      }\n\t    }\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Take a list of patches and return a textual representation.\n\t * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n\t * @return {string} Text representation of patches.\n\t */\n\tdiff_match_patch.prototype.patch_toText = function(patches) {\n\t  var text = [];\n\t  for (var x = 0; x < patches.length; x++) {\n\t    text[x] = patches[x];\n\t  }\n\t  return text.join('');\n\t};\n\t\n\t\n\t/**\n\t * Parse a textual representation of patches and return a list of patch objects.\n\t * @param {string} textline Text representation of patches.\n\t * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n\t * @throws {!Error} If invalid input.\n\t */\n\tdiff_match_patch.prototype.patch_fromText = function(textline) {\n\t  var patches = [];\n\t  if (!textline) {\n\t    return patches;\n\t  }\n\t  var text = textline.split('\\n');\n\t  var textPointer = 0;\n\t  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n\t  while (textPointer < text.length) {\n\t    var m = text[textPointer].match(patchHeader);\n\t    if (!m) {\n\t      throw new Error('Invalid patch string: ' + text[textPointer]);\n\t    }\n\t    var patch = new diff_match_patch.patch_obj();\n\t    patches.push(patch);\n\t    patch.start1 = parseInt(m[1], 10);\n\t    if (m[2] === '') {\n\t      patch.start1--;\n\t      patch.length1 = 1;\n\t    } else if (m[2] == '0') {\n\t      patch.length1 = 0;\n\t    } else {\n\t      patch.start1--;\n\t      patch.length1 = parseInt(m[2], 10);\n\t    }\n\t\n\t    patch.start2 = parseInt(m[3], 10);\n\t    if (m[4] === '') {\n\t      patch.start2--;\n\t      patch.length2 = 1;\n\t    } else if (m[4] == '0') {\n\t      patch.length2 = 0;\n\t    } else {\n\t      patch.start2--;\n\t      patch.length2 = parseInt(m[4], 10);\n\t    }\n\t    textPointer++;\n\t\n\t    while (textPointer < text.length) {\n\t      var sign = text[textPointer].charAt(0);\n\t      try {\n\t        var line = decodeURI(text[textPointer].substring(1));\n\t      } catch (ex) {\n\t        // Malformed URI sequence.\n\t        throw new Error('Illegal escape in patch_fromText: ' + line);\n\t      }\n\t      if (sign == '-') {\n\t        // Deletion.\n\t        patch.diffs.push([DIFF_DELETE, line]);\n\t      } else if (sign == '+') {\n\t        // Insertion.\n\t        patch.diffs.push([DIFF_INSERT, line]);\n\t      } else if (sign == ' ') {\n\t        // Minor equality.\n\t        patch.diffs.push([DIFF_EQUAL, line]);\n\t      } else if (sign == '@') {\n\t        // Start of next patch.\n\t        break;\n\t      } else if (sign === '') {\n\t        // Blank line?  Whatever.\n\t      } else {\n\t        // WTF?\n\t        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n\t      }\n\t      textPointer++;\n\t    }\n\t  }\n\t  return patches;\n\t};\n\t\n\t\n\t/**\n\t * Class representing one patch operation.\n\t * @constructor\n\t */\n\tdiff_match_patch.patch_obj = function() {\n\t  /** @type {!Array.<!diff_match_patch.Diff>} */\n\t  this.diffs = [];\n\t  /** @type {?number} */\n\t  this.start1 = null;\n\t  /** @type {?number} */\n\t  this.start2 = null;\n\t  /** @type {number} */\n\t  this.length1 = 0;\n\t  /** @type {number} */\n\t  this.length2 = 0;\n\t};\n\t\n\t\n\t/**\n\t * Emmulate GNU diff's format.\n\t * Header: @@ -382,8 +481,9 @@\n\t * Indicies are printed as 1-based, not 0-based.\n\t * @return {string} The GNU diff string.\n\t */\n\tdiff_match_patch.patch_obj.prototype.toString = function() {\n\t  var coords1, coords2;\n\t  if (this.length1 === 0) {\n\t    coords1 = this.start1 + ',0';\n\t  } else if (this.length1 == 1) {\n\t    coords1 = this.start1 + 1;\n\t  } else {\n\t    coords1 = (this.start1 + 1) + ',' + this.length1;\n\t  }\n\t  if (this.length2 === 0) {\n\t    coords2 = this.start2 + ',0';\n\t  } else if (this.length2 == 1) {\n\t    coords2 = this.start2 + 1;\n\t  } else {\n\t    coords2 = (this.start2 + 1) + ',' + this.length2;\n\t  }\n\t  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n\t  var op;\n\t  // Escape the body of the patch with %xx notation.\n\t  for (var x = 0; x < this.diffs.length; x++) {\n\t    switch (this.diffs[x][0]) {\n\t      case DIFF_INSERT:\n\t        op = '+';\n\t        break;\n\t      case DIFF_DELETE:\n\t        op = '-';\n\t        break;\n\t      case DIFF_EQUAL:\n\t        op = ' ';\n\t        break;\n\t    }\n\t    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n\t  }\n\t  return text.join('').replace(/%20/g, ' ');\n\t};\n\t\n\t\n\t// Export these global variables so that they survive Google's JS compiler.\n\t// In a browser, 'this' will be 'window'.\n\t// In node.js 'this' will be a global object.\n\tthis['diff_match_patch'] = diff_match_patch;\n\tthis['DIFF_DELETE'] = DIFF_DELETE;\n\tthis['DIFF_INSERT'] = DIFF_INSERT;\n\tthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\t\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tvar Pipe = function Pipe(name) {\n\t  this.name = name;\n\t  this.filters = [];\n\t};\n\t\n\tPipe.prototype.process = function(input) {\n\t  if (!this.processor) {\n\t    throw new Error('add this pipe to a processor before using it');\n\t  }\n\t  var debug = this.debug;\n\t  var length = this.filters.length;\n\t  var context = input;\n\t  for (var index = 0; index < length; index++) {\n\t    var filter = this.filters[index];\n\t    if (debug) {\n\t      this.log('filter: ' + filter.filterName);\n\t    }\n\t    filter(context);\n\t    if (typeof context === 'object' && context.exiting) {\n\t      context.exiting = false;\n\t      break;\n\t    }\n\t  }\n\t  if (!context.next && this.resultCheck) {\n\t    this.resultCheck(context);\n\t  }\n\t};\n\t\n\tPipe.prototype.log = function(msg) {\n\t  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n\t};\n\t\n\tPipe.prototype.append = function() {\n\t  this.filters.push.apply(this.filters, arguments);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.prepend = function() {\n\t  this.filters.unshift.apply(this.filters, arguments);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.indexOf = function(filterName) {\n\t  if (!filterName) {\n\t    throw new Error('a filter name is required');\n\t  }\n\t  for (var index = 0; index < this.filters.length; index++) {\n\t    var filter = this.filters[index];\n\t    if (filter.filterName === filterName) {\n\t      return index;\n\t    }\n\t  }\n\t  throw new Error('filter not found: ' + filterName);\n\t};\n\t\n\tPipe.prototype.list = function() {\n\t  var names = [];\n\t  for (var index = 0; index < this.filters.length; index++) {\n\t    var filter = this.filters[index];\n\t    names.push(filter.filterName);\n\t  }\n\t  return names;\n\t};\n\t\n\tPipe.prototype.after = function(filterName) {\n\t  var index = this.indexOf(filterName);\n\t  var params = Array.prototype.slice.call(arguments, 1);\n\t  if (!params.length) {\n\t    throw new Error('a filter is required');\n\t  }\n\t  params.unshift(index + 1, 0);\n\t  Array.prototype.splice.apply(this.filters, params);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.before = function(filterName) {\n\t  var index = this.indexOf(filterName);\n\t  var params = Array.prototype.slice.call(arguments, 1);\n\t  if (!params.length) {\n\t    throw new Error('a filter is required');\n\t  }\n\t  params.unshift(index, 0);\n\t  Array.prototype.splice.apply(this.filters, params);\n\t  return this;\n\t};\n\t\n\tPipe.prototype.clear = function() {\n\t  this.filters.length = 0;\n\t  return this;\n\t};\n\t\n\tPipe.prototype.shouldHaveResult = function(should) {\n\t  if (should === false) {\n\t    this.resultCheck = null;\n\t    return;\n\t  }\n\t  if (this.resultCheck) {\n\t    return;\n\t  }\n\t  var pipe = this;\n\t  this.resultCheck = function(context) {\n\t    if (!context.hasResult) {\n\t      console.log(context);\n\t      var error = new Error(pipe.name + ' failed');\n\t      error.noResult = true;\n\t      throw error;\n\t    }\n\t  };\n\t  return this;\n\t};\n\t\n\texports.Pipe = Pipe;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n\t                                                                                                                                                                                                                                                                   * # Stor\n\t                                                                                                                                                                                                                                                                   *\n\t                                                                                                                                                                                                                                                                   * A store enhancer which triggers change/update settings based on external events.\n\t                                                                                                                                                                                                                                                                   *\n\t                                                                                                                                                                                                                                                                   * TODO: checkout compatibity after upgrading redux, https://github.com/reactjs/redux/pull/1702\n\t                                                                                                                                                                                                                                                                   */\n\t\n\texports.default = syncStore;\n\t\n\tvar _jsonStringifySafe = __webpack_require__(8);\n\t\n\tvar _jsonStringifySafe2 = _interopRequireDefault(_jsonStringifySafe);\n\t\n\tvar _objectPath = __webpack_require__(19);\n\t\n\tvar _objectPath2 = _interopRequireDefault(_objectPath);\n\t\n\tvar _diffpatcher = __webpack_require__(11);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar diffpatcher = new _diffpatcher.DiffPatcher();\n\t\n\tvar INIT = '@@redux-sync/INIT';\n\tvar SYNC = '@@redux-sync/SYNC';\n\t\n\tvar defaultOptions = {\n\t  // exclude: [], // - allows to specify patterns for excludes\n\t  // include: [], // - allows to specify patterns for includes\n\t  root: null, // - optional: entry pointer what/where it should be synchronized !\n\t  id: '*' // - optional: used to differentiate if multiple sync stores are used!\n\t};\n\t\n\t// TODO: remove reference on unsubscribe/disconnect to avoid memory leak\n\tvar connections = Object.create(null);\n\t\n\tfunction syncStore(customOptions) {\n\t\n\t  if (customOptions && typeof customOptions === 'string') {\n\t    customOptions = { root: customOptions };\n\t  }\n\t\n\t  var options = _extends({}, defaultOptions);\n\t\n\t  if (customOptions) {\n\t    Object.assign(options, customOptions);\n\t  }\n\t\n\t  var env = {\n\t    isIframe: window !== window.parent\n\t  };\n\t\n\t  return function (createStore) {\n\t    return function (reducer, initialState) {\n\t\n\t      var store = createStore(reducer, initialState);\n\t\n\t      // get initial state after creation\n\t      var creationState = store.getState();\n\t\n\t      if (env.isIframe) {\n\t        var creationPatch = diffpatcher.diff({}, creationState);\n\t        sendMessage(options, window.parent, { type: INIT, state: creationState }, creationPatch);\n\t      }\n\t\n\t      // listen to internal dispatches to communicate (~ middlware)\n\t      var dispatch = function dispatch(action) {\n\t\n\t        var stateBefore = store.getState();\n\t        var result = store.dispatch(action);\n\t        var stateAfter = store.getState();\n\t\n\t        if (env.isIframe) {\n\t          var patch = diffpatcher.diff(stateBefore, stateAfter);\n\t          sendMessage(options, window.parent, action, patch);\n\t        } else {\n\t          var _patch = diffpatcher.diff(_objectPath2.default.get(stateBefore, options.root), _objectPath2.default.get(stateAfter, options.root));\n\t          if (_patch) {\n\t            var connection = connections[options.id];\n\t            connection && sendMessage(options, connection, action, _patch);\n\t          }\n\t        }\n\t\n\t        return result;\n\t      };\n\t\n\t      // listen to external messages\n\t      window.addEventListener('message', function (_ref) {\n\t        var data = _ref.data;\n\t        var origin = _ref.origin;\n\t        var source = _ref.source;\n\t\n\t        // filter by prefix\n\t        if (typeof data === 'string' && data.indexOf('redux-sync:') === 0) {\n\t          var _JSON$parse = JSON.parse(data.replace('redux-sync:', ''));\n\t\n\t          var id = _JSON$parse.id;\n\t          var trigger = _JSON$parse.trigger;\n\t          var patch = _JSON$parse.patch;\n\t\n\t\n\t          if (trigger.type === INIT) {\n\t            connections[id] = source;\n\t          }\n\t\n\t          store.dispatch({ type: SYNC, trigger: trigger, patch: patch });\n\t        }\n\t      });\n\t\n\t      // wrap reducer to patch data\n\t      store.replaceReducer(function () {\n\t        var state = arguments.length <= 0 || arguments[0] === undefined ? creationState : arguments[0];\n\t        var action = arguments[1];\n\t\n\t\n\t        if (action.type === SYNC) {\n\t          // TODO: handle/merge complex types of 'immutables'\n\t          // TODO: use selective approach for decoupling references (e.g. based on {...state})\n\t          state = JSON.parse((0, _jsonStringifySafe2.default)(state));\n\t          diffpatcher.patch(_objectPath2.default.get(state, options.root), action.patch);\n\t          return state;\n\t        }\n\t\n\t        return reducer(state, action);\n\t      });\n\t\n\t      return _extends({}, store, {\n\t        dispatch: dispatch\n\t      });\n\t    };\n\t  };\n\t}\n\t\n\t/**\n\t* Send triggering action and the complete state.\n\t* TODO: currently restricted to postMessages || could be extend to other channels (e.g. websocket)\n\t*\n\t* @param  {[type]} customOptions [description]\n\t* @param  {[type]} state         [description]\n\t* @return {[type]}               [description]\n\t*/\n\tfunction sendMessage(options, scope, action, patch) {\n\t  scope && scope.postMessage('redux-sync:' + (0, _jsonStringifySafe2.default)({\n\t    id: options.id,\n\t    trigger: action,\n\t    patch: patch\n\t  }), '*');\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\texports = module.exports = stringify\n\texports.getSerialize = serializer\n\t\n\tfunction stringify(obj, replacer, spaces, cycleReplacer) {\n\t  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n\t}\n\t\n\tfunction serializer(replacer, cycleReplacer) {\n\t  var stack = [], keys = []\n\t\n\t  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n\t    if (stack[0] === value) return \"[Circular ~]\"\n\t    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n\t  }\n\t\n\t  return function(key, value) {\n\t    if (stack.length > 0) {\n\t      var thisPos = stack.indexOf(this)\n\t      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n\t      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n\t      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n\t    }\n\t    else stack.push(value)\n\t\n\t    return replacer == null ? value : replacer.call(this, key, value)\n\t  }\n\t}\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar map = {\n\t\t\"./diff_match_patch_uncompressed\": 5,\n\t\t\"./diff_match_patch_uncompressed.js\": 5\n\t};\n\tfunction webpackContext(req) {\n\t\treturn __webpack_require__(webpackContextResolve(req));\n\t};\n\tfunction webpackContextResolve(req) {\n\t\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n\t};\n\twebpackContext.keys = function webpackContextKeys() {\n\t\treturn Object.keys(map);\n\t};\n\twebpackContext.resolve = webpackContextResolve;\n\tmodule.exports = webpackContext;\n\twebpackContext.id = 9;\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t// use as 2nd parameter for JSON.parse to revive Date instances\n\tmodule.exports = function dateReviver(key, value) {\n\t  var parts;\n\t  if (typeof value === 'string') {\n\t    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+\\-])(\\d{2}):(\\d{2}))$/.exec(value);\n\t    if (parts) {\n\t      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n\t    }\n\t  }\n\t  return value;\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Processor = __webpack_require__(18).Processor;\n\tvar Pipe = __webpack_require__(6).Pipe;\n\tvar DiffContext = __webpack_require__(2).DiffContext;\n\tvar PatchContext = __webpack_require__(3).PatchContext;\n\tvar ReverseContext = __webpack_require__(4).ReverseContext;\n\t\n\tvar trivial = __webpack_require__(17);\n\tvar nested = __webpack_require__(15);\n\tvar arrays = __webpack_require__(12);\n\tvar dates = __webpack_require__(13);\n\tvar texts = __webpack_require__(16);\n\t\n\tvar DiffPatcher = function DiffPatcher(options) {\n\t  this.processor = new Processor(options);\n\t  this.processor.pipe(new Pipe('diff').append(\n\t    nested.collectChildrenDiffFilter,\n\t    trivial.diffFilter,\n\t    dates.diffFilter,\n\t    texts.diffFilter,\n\t    nested.objectsDiffFilter,\n\t    arrays.diffFilter\n\t  ).shouldHaveResult());\n\t  this.processor.pipe(new Pipe('patch').append(\n\t    nested.collectChildrenPatchFilter,\n\t    arrays.collectChildrenPatchFilter,\n\t    trivial.patchFilter,\n\t    texts.patchFilter,\n\t    nested.patchFilter,\n\t    arrays.patchFilter\n\t  ).shouldHaveResult());\n\t  this.processor.pipe(new Pipe('reverse').append(\n\t    nested.collectChildrenReverseFilter,\n\t    arrays.collectChildrenReverseFilter,\n\t    trivial.reverseFilter,\n\t    texts.reverseFilter,\n\t    nested.reverseFilter,\n\t    arrays.reverseFilter\n\t  ).shouldHaveResult());\n\t};\n\t\n\tDiffPatcher.prototype.options = function() {\n\t  return this.processor.options.apply(this.processor, arguments);\n\t};\n\t\n\tDiffPatcher.prototype.diff = function(left, right) {\n\t  return this.processor.process(new DiffContext(left, right));\n\t};\n\t\n\tDiffPatcher.prototype.patch = function(left, delta) {\n\t  return this.processor.process(new PatchContext(left, delta));\n\t};\n\t\n\tDiffPatcher.prototype.reverse = function(delta) {\n\t  return this.processor.process(new ReverseContext(delta));\n\t};\n\t\n\tDiffPatcher.prototype.unpatch = function(right, delta) {\n\t  return this.patch(right, this.reverse(delta));\n\t};\n\t\n\texports.DiffPatcher = DiffPatcher;\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DiffContext = __webpack_require__(2).DiffContext;\n\tvar PatchContext = __webpack_require__(3).PatchContext;\n\tvar ReverseContext = __webpack_require__(4).ReverseContext;\n\t\n\tvar lcs = __webpack_require__(14);\n\t\n\tvar ARRAY_MOVE = 3;\n\t\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?\n\t  function(array, item) {\n\t    return array.indexOf(item);\n\t  } : function(array, item) {\n\t    var length = array.length;\n\t    for (var i = 0; i < length; i++) {\n\t      if (array[i] === item) {\n\t        return i;\n\t      }\n\t    }\n\t    return -1;\n\t  };\n\t\n\tfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n\t  for (var index1 = 0; index1 < len1; index1++) {\n\t    var val1 = array1[index1];\n\t    for (var index2 = 0; index2 < len2; index2++) {\n\t      var val2 = array2[index2];\n\t      if (val1 === val2) {\n\t        return true;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction matchItems(array1, array2, index1, index2, context) {\n\t  var value1 = array1[index1];\n\t  var value2 = array2[index2];\n\t  if (value1 === value2) {\n\t    return true;\n\t  }\n\t  if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n\t    return false;\n\t  }\n\t  var objectHash = context.objectHash;\n\t  if (!objectHash) {\n\t    // no way to match objects was provided, try match by position\n\t    return context.matchByPosition && index1 === index2;\n\t  }\n\t  var hash1;\n\t  var hash2;\n\t  if (typeof index1 === 'number') {\n\t    context.hashCache1 = context.hashCache1 || [];\n\t    hash1 = context.hashCache1[index1];\n\t    if (typeof hash1 === 'undefined') {\n\t      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n\t    }\n\t  } else {\n\t    hash1 = objectHash(value1);\n\t  }\n\t  if (typeof hash1 === 'undefined') {\n\t    return false;\n\t  }\n\t  if (typeof index2 === 'number') {\n\t    context.hashCache2 = context.hashCache2 || [];\n\t    hash2 = context.hashCache2[index2];\n\t    if (typeof hash2 === 'undefined') {\n\t      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n\t    }\n\t  } else {\n\t    hash2 = objectHash(value2);\n\t  }\n\t  if (typeof hash2 === 'undefined') {\n\t    return false;\n\t  }\n\t  return hash1 === hash2;\n\t}\n\t\n\tvar diffFilter = function arraysDiffFilter(context) {\n\t  if (!context.leftIsArray) {\n\t    return;\n\t  }\n\t\n\t  var matchContext = {\n\t    objectHash: context.options && context.options.objectHash,\n\t    matchByPosition: context.options && context.options.matchByPosition\n\t  };\n\t  var commonHead = 0;\n\t  var commonTail = 0;\n\t  var index;\n\t  var index1;\n\t  var index2;\n\t  var array1 = context.left;\n\t  var array2 = context.right;\n\t  var len1 = array1.length;\n\t  var len2 = array2.length;\n\t\n\t  var child;\n\t\n\t  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&\n\t    typeof matchContext.matchByPosition !== 'boolean') {\n\t    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n\t  }\n\t\n\t  // separate common head\n\t  while (commonHead < len1 && commonHead < len2 &&\n\t    matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n\t    index = commonHead;\n\t    child = new DiffContext(context.left[index], context.right[index]);\n\t    context.push(child, index);\n\t    commonHead++;\n\t  }\n\t  // separate common tail\n\t  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&\n\t    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n\t    index1 = len1 - 1 - commonTail;\n\t    index2 = len2 - 1 - commonTail;\n\t    child = new DiffContext(context.left[index1], context.right[index2]);\n\t    context.push(child, index2);\n\t    commonTail++;\n\t  }\n\t  var result;\n\t  if (commonHead + commonTail === len1) {\n\t    if (len1 === len2) {\n\t      // arrays are identical\n\t      context.setResult(undefined).exit();\n\t      return;\n\t    }\n\t    // trivial case, a block (1 or more consecutive items) was added\n\t    result = result || {\n\t      _t: 'a'\n\t    };\n\t    for (index = commonHead; index < len2 - commonTail; index++) {\n\t      result[index] = [array2[index]];\n\t    }\n\t    context.setResult(result).exit();\n\t    return;\n\t  }\n\t  if (commonHead + commonTail === len2) {\n\t    // trivial case, a block (1 or more consecutive items) was removed\n\t    result = result || {\n\t      _t: 'a'\n\t    };\n\t    for (index = commonHead; index < len1 - commonTail; index++) {\n\t      result['_' + index] = [array1[index], 0, 0];\n\t    }\n\t    context.setResult(result).exit();\n\t    return;\n\t  }\n\t  // reset hash cache\n\t  delete matchContext.hashCache1;\n\t  delete matchContext.hashCache2;\n\t\n\t  // diff is not trivial, find the LCS (Longest Common Subsequence)\n\t  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n\t  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n\t  var seq = lcs.get(\n\t    trimmed1, trimmed2,\n\t    matchItems,\n\t    matchContext\n\t  );\n\t  var removedItems = [];\n\t  result = result || {\n\t    _t: 'a'\n\t  };\n\t  for (index = commonHead; index < len1 - commonTail; index++) {\n\t    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n\t      // removed\n\t      result['_' + index] = [array1[index], 0, 0];\n\t      removedItems.push(index);\n\t    }\n\t  }\n\t\n\t  var detectMove = true;\n\t  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n\t    detectMove = false;\n\t  }\n\t  var includeValueOnMove = false;\n\t  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n\t    includeValueOnMove = true;\n\t  }\n\t\n\t  var removedItemsLength = removedItems.length;\n\t  for (index = commonHead; index < len2 - commonTail; index++) {\n\t    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n\t    if (indexOnArray2 < 0) {\n\t      // added, try to match with a removed item and register as position move\n\t      var isMove = false;\n\t      if (detectMove && removedItemsLength > 0) {\n\t        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n\t          index1 = removedItems[removeItemIndex1];\n\t          if (matchItems(trimmed1, trimmed2, index1 - commonHead,\n\t            index - commonHead, matchContext)) {\n\t            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n\t            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n\t            if (!includeValueOnMove) {\n\t              // don't include moved value on diff, to save bytes\n\t              result['_' + index1][0] = '';\n\t            }\n\t\n\t            index2 = index;\n\t            child = new DiffContext(context.left[index1], context.right[index2]);\n\t            context.push(child, index2);\n\t            removedItems.splice(removeItemIndex1, 1);\n\t            isMove = true;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      if (!isMove) {\n\t        // added\n\t        result[index] = [array2[index]];\n\t      }\n\t    } else {\n\t      // match, do inner diff\n\t      index1 = seq.indices1[indexOnArray2] + commonHead;\n\t      index2 = seq.indices2[indexOnArray2] + commonHead;\n\t      child = new DiffContext(context.left[index1], context.right[index2]);\n\t      context.push(child, index2);\n\t    }\n\t  }\n\t\n\t  context.setResult(result).exit();\n\t\n\t};\n\tdiffFilter.filterName = 'arrays';\n\t\n\tvar compare = {\n\t  numerically: function(a, b) {\n\t    return a - b;\n\t  },\n\t  numericallyBy: function(name) {\n\t    return function(a, b) {\n\t      return a[name] - b[name];\n\t    };\n\t  }\n\t};\n\t\n\tvar patchFilter = function nestedPatchFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var index, index1;\n\t\n\t  var delta = context.delta;\n\t  var array = context.left;\n\t\n\t  // first, separate removals, insertions and modifications\n\t  var toRemove = [];\n\t  var toInsert = [];\n\t  var toModify = [];\n\t  for (index in delta) {\n\t    if (index !== '_t') {\n\t      if (index[0] === '_') {\n\t        // removed item from original array\n\t        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n\t          toRemove.push(parseInt(index.slice(1), 10));\n\t        } else {\n\t          throw new Error('only removal or move can be applied at original array indices' +\n\t            ', invalid diff type: ' + delta[index][2]);\n\t        }\n\t      } else {\n\t        if (delta[index].length === 1) {\n\t          // added item at new array\n\t          toInsert.push({\n\t            index: parseInt(index, 10),\n\t            value: delta[index][0]\n\t          });\n\t        } else {\n\t          // modified item at new array\n\t          toModify.push({\n\t            index: parseInt(index, 10),\n\t            delta: delta[index]\n\t          });\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // remove items, in reverse order to avoid sawing our own floor\n\t  toRemove = toRemove.sort(compare.numerically);\n\t  for (index = toRemove.length - 1; index >= 0; index--) {\n\t    index1 = toRemove[index];\n\t    var indexDiff = delta['_' + index1];\n\t    var removedValue = array.splice(index1, 1)[0];\n\t    if (indexDiff[2] === ARRAY_MOVE) {\n\t      // reinsert later\n\t      toInsert.push({\n\t        index: indexDiff[1],\n\t        value: removedValue\n\t      });\n\t    }\n\t  }\n\t\n\t  // insert items, in reverse order to avoid moving our own floor\n\t  toInsert = toInsert.sort(compare.numericallyBy('index'));\n\t  var toInsertLength = toInsert.length;\n\t  for (index = 0; index < toInsertLength; index++) {\n\t    var insertion = toInsert[index];\n\t    array.splice(insertion.index, 0, insertion.value);\n\t  }\n\t\n\t  // apply modifications\n\t  var toModifyLength = toModify.length;\n\t  var child;\n\t  if (toModifyLength > 0) {\n\t    for (index = 0; index < toModifyLength; index++) {\n\t      var modification = toModify[index];\n\t      child = new PatchContext(context.left[modification.index], modification.delta);\n\t      context.push(child, modification.index);\n\t    }\n\t  }\n\t\n\t  if (!context.children) {\n\t    context.setResult(context.left).exit();\n\t    return;\n\t  }\n\t  context.exit();\n\t};\n\tpatchFilter.filterName = 'arrays';\n\t\n\tvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    context.left[child.childName] = child.result;\n\t  }\n\t  context.setResult(context.left).exit();\n\t};\n\tcollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\n\t\n\tvar reverseFilter = function arraysReverseFilter(context) {\n\t  if (!context.nested) {\n\t    if (context.delta[2] === ARRAY_MOVE) {\n\t      context.newName = '_' + context.delta[1];\n\t      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n\t    }\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    if (name === '_t') {\n\t      continue;\n\t    }\n\t    child = new ReverseContext(context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\treverseFilter.filterName = 'arrays';\n\t\n\tvar reverseArrayDeltaIndex = function(delta, index, itemDelta) {\n\t  if (typeof index === 'string' && index[0] === '_') {\n\t    return parseInt(index.substr(1), 10);\n\t  } else if (isArray(itemDelta) && itemDelta[2] === 0) {\n\t    return '_' + index;\n\t  }\n\t\n\t  var reverseIndex = +index;\n\t  for (var deltaIndex in delta) {\n\t    var deltaItem = delta[deltaIndex];\n\t    if (isArray(deltaItem)) {\n\t      if (deltaItem[2] === ARRAY_MOVE) {\n\t        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n\t        var moveToIndex = deltaItem[1];\n\t        if (moveToIndex === +index) {\n\t          return moveFromIndex;\n\t        }\n\t        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n\t          reverseIndex++;\n\t        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n\t          reverseIndex--;\n\t        }\n\t      } else if (deltaItem[2] === 0) {\n\t        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n\t        if (deleteIndex <= reverseIndex) {\n\t          reverseIndex++;\n\t        }\n\t      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n\t        reverseIndex--;\n\t      }\n\t    }\n\t  }\n\t\n\t  return reverseIndex;\n\t};\n\t\n\tvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t !== 'a') {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var delta = {\n\t    _t: 'a'\n\t  };\n\t\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    var name = child.newName;\n\t    if (typeof name === 'undefined') {\n\t      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n\t    }\n\t    if (delta[name] !== child.result) {\n\t      delta[name] = child.result;\n\t    }\n\t  }\n\t  context.setResult(delta).exit();\n\t};\n\tcollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.collectChildrenPatchFilter = collectChildrenPatchFilter;\n\texports.reverseFilter = reverseFilter;\n\texports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tvar diffFilter = function datesDiffFilter(context) {\n\t  if (context.left instanceof Date) {\n\t    if (context.right instanceof Date) {\n\t      if (context.left.getTime() !== context.right.getTime()) {\n\t        context.setResult([context.left, context.right]);\n\t      } else {\n\t        context.setResult(undefined);\n\t      }\n\t    } else {\n\t      context.setResult([context.left, context.right]);\n\t    }\n\t    context.exit();\n\t  } else if (context.right instanceof Date) {\n\t    context.setResult([context.left, context.right]).exit();\n\t  }\n\t};\n\tdiffFilter.filterName = 'dates';\n\t\n\texports.diffFilter = diffFilter;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/*\n\t\n\tLCS implementation that supports arrays or strings\n\t\n\treference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\t\n\t*/\n\t\n\tvar defaultMatch = function(array1, array2, index1, index2) {\n\t  return array1[index1] === array2[index2];\n\t};\n\t\n\tvar lengthMatrix = function(array1, array2, match, context) {\n\t  var len1 = array1.length;\n\t  var len2 = array2.length;\n\t  var x, y;\n\t\n\t  // initialize empty matrix of len1+1 x len2+1\n\t  var matrix = [len1 + 1];\n\t  for (x = 0; x < len1 + 1; x++) {\n\t    matrix[x] = [len2 + 1];\n\t    for (y = 0; y < len2 + 1; y++) {\n\t      matrix[x][y] = 0;\n\t    }\n\t  }\n\t  matrix.match = match;\n\t  // save sequence lengths for each coordinate\n\t  for (x = 1; x < len1 + 1; x++) {\n\t    for (y = 1; y < len2 + 1; y++) {\n\t      if (match(array1, array2, x - 1, y - 1, context)) {\n\t        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n\t      } else {\n\t        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n\t      }\n\t    }\n\t  }\n\t  return matrix;\n\t};\n\t\n\tvar backtrack = function(matrix, array1, array2, index1, index2, context) {\n\t  if (index1 === 0 || index2 === 0) {\n\t    return {\n\t      sequence: [],\n\t      indices1: [],\n\t      indices2: []\n\t    };\n\t  }\n\t\n\t  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n\t    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);\n\t    subsequence.sequence.push(array1[index1 - 1]);\n\t    subsequence.indices1.push(index1 - 1);\n\t    subsequence.indices2.push(index2 - 1);\n\t    return subsequence;\n\t  }\n\t\n\t  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n\t    return backtrack(matrix, array1, array2, index1, index2 - 1, context);\n\t  } else {\n\t    return backtrack(matrix, array1, array2, index1 - 1, index2, context);\n\t  }\n\t};\n\t\n\tvar get = function(array1, array2, match, context) {\n\t  context = context || {};\n\t  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);\n\t  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);\n\t  if (typeof array1 === 'string' && typeof array2 === 'string') {\n\t    result.sequence = result.sequence.join('');\n\t  }\n\t  return result;\n\t};\n\t\n\texports.get = get;\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DiffContext = __webpack_require__(2).DiffContext;\n\tvar PatchContext = __webpack_require__(3).PatchContext;\n\tvar ReverseContext = __webpack_require__(4).ReverseContext;\n\t\n\tvar collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var result = context.result;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (typeof child.result === 'undefined') {\n\t      continue;\n\t    }\n\t    result = result || {};\n\t    result[child.childName] = child.result;\n\t  }\n\t  if (result && context.leftIsArray) {\n\t    result._t = 'a';\n\t  }\n\t  context.setResult(result).exit();\n\t};\n\tcollectChildrenDiffFilter.filterName = 'collectChildren';\n\t\n\tvar objectsDiffFilter = function objectsDiffFilter(context) {\n\t  if (context.leftIsArray || context.leftType !== 'object') {\n\t    return;\n\t  }\n\t\n\t  var name, child, propertyFilter = context.options.propertyFilter;\n\t  for (name in context.left) {\n\t    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n\t      continue;\n\t    }\n\t    if (propertyFilter && !propertyFilter(name, context)) {\n\t      continue;\n\t    }\n\t    child = new DiffContext(context.left[name], context.right[name]);\n\t    context.push(child, name);\n\t  }\n\t  for (name in context.right) {\n\t    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n\t      continue;\n\t    }\n\t    if (propertyFilter && !propertyFilter(name, context)) {\n\t      continue;\n\t    }\n\t    if (typeof context.left[name] === 'undefined') {\n\t      child = new DiffContext(undefined, context.right[name]);\n\t      context.push(child, name);\n\t    }\n\t  }\n\t\n\t  if (!context.children || context.children.length === 0) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t  context.exit();\n\t};\n\tobjectsDiffFilter.filterName = 'objects';\n\t\n\tvar patchFilter = function nestedPatchFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    child = new PatchContext(context.left[name], context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\tpatchFilter.filterName = 'objects';\n\t\n\tvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n\t      delete context.left[child.childName];\n\t    } else if (context.left[child.childName] !== child.result) {\n\t      context.left[child.childName] = child.result;\n\t    }\n\t  }\n\t  context.setResult(context.left).exit();\n\t};\n\tcollectChildrenPatchFilter.filterName = 'collectChildren';\n\t\n\tvar reverseFilter = function nestedReverseFilter(context) {\n\t  if (!context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var name, child;\n\t  for (name in context.delta) {\n\t    child = new ReverseContext(context.delta[name]);\n\t    context.push(child, name);\n\t  }\n\t  context.exit();\n\t};\n\treverseFilter.filterName = 'objects';\n\t\n\tvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n\t  if (!context || !context.children) {\n\t    return;\n\t  }\n\t  if (context.delta._t) {\n\t    return;\n\t  }\n\t  var length = context.children.length;\n\t  var child;\n\t  var delta = {};\n\t  for (var index = 0; index < length; index++) {\n\t    child = context.children[index];\n\t    if (delta[child.childName] !== child.result) {\n\t      delta[child.childName] = child.result;\n\t    }\n\t  }\n\t  context.setResult(delta).exit();\n\t};\n\tcollectChildrenReverseFilter.filterName = 'collectChildren';\n\t\n\texports.collectChildrenDiffFilter = collectChildrenDiffFilter;\n\texports.objectsDiffFilter = objectsDiffFilter;\n\texports.patchFilter = patchFilter;\n\texports.collectChildrenPatchFilter = collectChildrenPatchFilter;\n\texports.reverseFilter = reverseFilter;\n\texports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* global diff_match_patch */\n\tvar TEXT_DIFF = 2;\n\tvar DEFAULT_MIN_LENGTH = 60;\n\tvar cachedDiffPatch = null;\n\t\n\tvar getDiffMatchPatch = function(required) {\n\t  /*jshint camelcase: false */\n\t\n\t  if (!cachedDiffPatch) {\n\t    var instance;\n\t    if (typeof diff_match_patch !== 'undefined') {\n\t      // already loaded, probably a browser\n\t      instance = typeof diff_match_patch === 'function' ?\n\t        new diff_match_patch() : new diff_match_patch.diff_match_patch();\n\t    } else if (true) {\n\t      try {\n\t        var dmpModuleName = 'diff_match_patch_uncompressed';\n\t        var dmp = __webpack_require__(9)(\"./\" + dmpModuleName);\n\t        instance = new dmp.diff_match_patch();\n\t      } catch (err) {\n\t        instance = null;\n\t      }\n\t    }\n\t    if (!instance) {\n\t      if (!required) {\n\t        return null;\n\t      }\n\t      var error = new Error('text diff_match_patch library not found');\n\t      error.diff_match_patch_not_found = true;\n\t      throw error;\n\t    }\n\t    cachedDiffPatch = {\n\t      diff: function(txt1, txt2) {\n\t        return instance.patch_toText(instance.patch_make(txt1, txt2));\n\t      },\n\t      patch: function(txt1, patch) {\n\t        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);\n\t        for (var i = 0; i < results[1].length; i++) {\n\t          if (!results[1][i]) {\n\t            var error = new Error('text patch failed');\n\t            error.textPatchFailed = true;\n\t          }\n\t        }\n\t        return results[0];\n\t      }\n\t    };\n\t  }\n\t  return cachedDiffPatch;\n\t};\n\t\n\tvar diffFilter = function textsDiffFilter(context) {\n\t  if (context.leftType !== 'string') {\n\t    return;\n\t  }\n\t  var minLength = (context.options && context.options.textDiff &&\n\t    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;\n\t  if (context.left.length < minLength ||\n\t    context.right.length < minLength) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  // large text, try to use a text-diff algorithm\n\t  var diffMatchPatch = getDiffMatchPatch();\n\t  if (!diffMatchPatch) {\n\t    // diff-match-patch library not available, fallback to regular string replace\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  var diff = diffMatchPatch.diff;\n\t  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n\t};\n\tdiffFilter.filterName = 'texts';\n\t\n\tvar patchFilter = function textsPatchFilter(context) {\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta[2] !== TEXT_DIFF) {\n\t    return;\n\t  }\n\t\n\t  // text-diff, use a text-patch algorithm\n\t  var patch = getDiffMatchPatch(true).patch;\n\t  context.setResult(patch(context.left, context.delta[0])).exit();\n\t};\n\tpatchFilter.filterName = 'texts';\n\t\n\tvar textDeltaReverse = function(delta) {\n\t  var i, l, lines, line, lineTmp, header = null,\n\t    headerRegex = /^@@ +\\-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/,\n\t    lineHeader, lineAdd, lineRemove;\n\t  lines = delta.split('\\n');\n\t  for (i = 0, l = lines.length; i < l; i++) {\n\t    line = lines[i];\n\t    var lineStart = line.slice(0, 1);\n\t    if (lineStart === '@') {\n\t      header = headerRegex.exec(line);\n\t      lineHeader = i;\n\t      lineAdd = null;\n\t      lineRemove = null;\n\t\n\t      // fix header\n\t      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n\t    } else if (lineStart === '+') {\n\t      lineAdd = i;\n\t      lines[i] = '-' + lines[i].slice(1);\n\t      if (lines[i - 1].slice(0, 1) === '+') {\n\t        // swap lines to keep default order (-+)\n\t        lineTmp = lines[i];\n\t        lines[i] = lines[i - 1];\n\t        lines[i - 1] = lineTmp;\n\t      }\n\t    } else if (lineStart === '-') {\n\t      lineRemove = i;\n\t      lines[i] = '+' + lines[i].slice(1);\n\t    }\n\t  }\n\t  return lines.join('\\n');\n\t};\n\t\n\tvar reverseFilter = function textsReverseFilter(context) {\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta[2] !== TEXT_DIFF) {\n\t    return;\n\t  }\n\t\n\t  // text-diff, use a text-diff algorithm\n\t  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n\t};\n\treverseFilter.filterName = 'texts';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.reverseFilter = reverseFilter;\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tvar isArray = (typeof Array.isArray === 'function') ?\n\t  // use native function\n\t  Array.isArray :\n\t  // use instanceof operator\n\t  function(a) {\n\t    return a instanceof Array;\n\t  };\n\t\n\tvar diffFilter = function trivialMatchesDiffFilter(context) {\n\t  if (context.left === context.right) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t  if (typeof context.left === 'undefined') {\n\t    if (typeof context.right === 'function') {\n\t      throw new Error('functions are not supported');\n\t    }\n\t    context.setResult([context.right]).exit();\n\t    return;\n\t  }\n\t  if (typeof context.right === 'undefined') {\n\t    context.setResult([context.left, 0, 0]).exit();\n\t    return;\n\t  }\n\t  if (typeof context.left === 'function' || typeof context.right === 'function') {\n\t    throw new Error('functions are not supported');\n\t  }\n\t  context.leftType = context.left === null ? 'null' : typeof context.left;\n\t  context.rightType = context.right === null ? 'null' : typeof context.right;\n\t  if (context.leftType !== context.rightType) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  if (context.leftType === 'boolean' || context.leftType === 'number') {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t  if (context.leftType === 'object') {\n\t    context.leftIsArray = isArray(context.left);\n\t  }\n\t  if (context.rightType === 'object') {\n\t    context.rightIsArray = isArray(context.right);\n\t  }\n\t  if (context.leftIsArray !== context.rightIsArray) {\n\t    context.setResult([context.left, context.right]).exit();\n\t    return;\n\t  }\n\t};\n\tdiffFilter.filterName = 'trivial';\n\t\n\tvar patchFilter = function trivialMatchesPatchFilter(context) {\n\t  if (typeof context.delta === 'undefined') {\n\t    context.setResult(context.left).exit();\n\t    return;\n\t  }\n\t  context.nested = !isArray(context.delta);\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta.length === 1) {\n\t    context.setResult(context.delta[0]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 2) {\n\t    context.setResult(context.delta[1]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 3 && context.delta[2] === 0) {\n\t    context.setResult(undefined).exit();\n\t    return;\n\t  }\n\t};\n\tpatchFilter.filterName = 'trivial';\n\t\n\tvar reverseFilter = function trivialReferseFilter(context) {\n\t  if (typeof context.delta === 'undefined') {\n\t    context.setResult(context.delta).exit();\n\t    return;\n\t  }\n\t  context.nested = !isArray(context.delta);\n\t  if (context.nested) {\n\t    return;\n\t  }\n\t  if (context.delta.length === 1) {\n\t    context.setResult([context.delta[0], 0, 0]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 2) {\n\t    context.setResult([context.delta[1], context.delta[0]]).exit();\n\t    return;\n\t  }\n\t  if (context.delta.length === 3 && context.delta[2] === 0) {\n\t    context.setResult([context.delta[0]]).exit();\n\t    return;\n\t  }\n\t};\n\treverseFilter.filterName = 'trivial';\n\t\n\texports.diffFilter = diffFilter;\n\texports.patchFilter = patchFilter;\n\texports.reverseFilter = reverseFilter;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\n\tvar Processor = function Processor(options){\n\t  this.selfOptions = options || {};\n\t  this.pipes = {};\n\t};\n\t\n\tProcessor.prototype.options = function(options) {\n\t  if (options) {\n\t    this.selfOptions = options;\n\t  }\n\t  return this.selfOptions;\n\t};\n\t\n\tProcessor.prototype.pipe = function(name, pipe) {\n\t  if (typeof name === 'string') {\n\t    if (typeof pipe === 'undefined') {\n\t      return this.pipes[name];\n\t    } else {\n\t      this.pipes[name] = pipe;\n\t    }\n\t  }\n\t  if (name && name.name) {\n\t    pipe = name;\n\t    if (pipe.processor === this) { return pipe; }\n\t    this.pipes[pipe.name] = pipe;\n\t  }\n\t  pipe.processor = this;\n\t  return pipe;\n\t};\n\t\n\tProcessor.prototype.process = function(input, pipe) {\n\t  var context = input;\n\t  context.options = this.options();\n\t  var nextPipe = pipe || input.pipe || 'default';\n\t  var lastPipe, lastContext;\n\t  while (nextPipe) {\n\t    if (typeof context.nextAfterChildren !== 'undefined') {\n\t      // children processed and coming back to parent\n\t      context.next = context.nextAfterChildren;\n\t      context.nextAfterChildren = null;\n\t    }\n\t\n\t    if (typeof nextPipe === 'string') {\n\t      nextPipe = this.pipe(nextPipe);\n\t    }\n\t    nextPipe.process(context);\n\t    lastContext = context;\n\t    lastPipe = nextPipe;\n\t    nextPipe = null;\n\t    if (context) {\n\t      if (context.next) {\n\t        context = context.next;\n\t        nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n\t      }\n\t    }\n\t  }\n\t  return context.hasResult ? context.result : undefined;\n\t};\n\t\n\texports.Processor = Processor;\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory){\n\t  'use strict';\n\t\n\t  /*istanbul ignore next:cant test*/\n\t  if (typeof module === 'object' && typeof module.exports === 'object') {\n\t    module.exports = factory();\n\t  } else if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else {\n\t    // Browser globals\n\t    root.objectPath = factory();\n\t  }\n\t})(this, function(){\n\t  'use strict';\n\t\n\t  var\n\t    toStr = Object.prototype.toString,\n\t    _hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t  function isEmpty(value){\n\t    if (!value) {\n\t      return true;\n\t    }\n\t    if (isArray(value) && value.length === 0) {\n\t        return true;\n\t    } else if (!isString(value)) {\n\t        for (var i in value) {\n\t            if (_hasOwnProperty.call(value, i)) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function toString(type){\n\t    return toStr.call(type);\n\t  }\n\t\n\t  function isNumber(value){\n\t    return typeof value === 'number' || toString(value) === \"[object Number]\";\n\t  }\n\t\n\t  function isString(obj){\n\t    return typeof obj === 'string' || toString(obj) === \"[object String]\";\n\t  }\n\t\n\t  function isObject(obj){\n\t    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n\t  }\n\t\n\t  function isArray(obj){\n\t    return typeof obj === 'object' && typeof obj.length === 'number' && toString(obj) === '[object Array]';\n\t  }\n\t\n\t  function isBoolean(obj){\n\t    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n\t  }\n\t\n\t  function getKey(key){\n\t    var intKey = parseInt(key);\n\t    if (intKey.toString() === key) {\n\t      return intKey;\n\t    }\n\t    return key;\n\t  }\n\t\n\t  function set(obj, path, value, doNotReplace){\n\t    if (isNumber(path)) {\n\t      path = [path];\n\t    }\n\t    if (isEmpty(path)) {\n\t      return obj;\n\t    }\n\t    if (isString(path)) {\n\t      return set(obj, path.split('.').map(getKey), value, doNotReplace);\n\t    }\n\t    var currentPath = path[0];\n\t\n\t    if (path.length === 1) {\n\t      var oldVal = obj[currentPath];\n\t      if (oldVal === void 0 || !doNotReplace) {\n\t        obj[currentPath] = value;\n\t      }\n\t      return oldVal;\n\t    }\n\t\n\t    if (obj[currentPath] === void 0) {\n\t      //check if we assume an array\n\t      if(isNumber(path[1])) {\n\t        obj[currentPath] = [];\n\t      } else {\n\t        obj[currentPath] = {};\n\t      }\n\t    }\n\t\n\t    return set(obj[currentPath], path.slice(1), value, doNotReplace);\n\t  }\n\t\n\t  function del(obj, path) {\n\t    if (isNumber(path)) {\n\t      path = [path];\n\t    }\n\t\n\t    if (isEmpty(obj)) {\n\t      return void 0;\n\t    }\n\t\n\t    if (isEmpty(path)) {\n\t      return obj;\n\t    }\n\t    if(isString(path)) {\n\t      return del(obj, path.split('.'));\n\t    }\n\t\n\t    var currentPath = getKey(path[0]);\n\t    var oldVal = obj[currentPath];\n\t\n\t    if(path.length === 1) {\n\t      if (oldVal !== void 0) {\n\t        if (isArray(obj)) {\n\t          obj.splice(currentPath, 1);\n\t        } else {\n\t          delete obj[currentPath];\n\t        }\n\t      }\n\t    } else {\n\t      if (obj[currentPath] !== void 0) {\n\t        return del(obj[currentPath], path.slice(1));\n\t      }\n\t    }\n\t\n\t    return obj;\n\t  }\n\t\n\t  var objectPath = function(obj) {\n\t    return Object.keys(objectPath).reduce(function(proxy, prop) {\n\t      if (typeof objectPath[prop] === 'function') {\n\t        proxy[prop] = objectPath[prop].bind(objectPath, obj);\n\t      }\n\t\n\t      return proxy;\n\t    }, {});\n\t  };\n\t\n\t  objectPath.has = function (obj, path) {\n\t    if (isEmpty(obj)) {\n\t      return false;\n\t    }\n\t\n\t    if (isNumber(path)) {\n\t      path = [path];\n\t    } else if (isString(path)) {\n\t      path = path.split('.');\n\t    }\n\t\n\t    if (isEmpty(path) || path.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    for (var i = 0; i < path.length; i++) {\n\t      var j = path[i];\n\t      if ((isObject(obj) || isArray(obj)) && _hasOwnProperty.call(obj, j)) {\n\t        obj = obj[j];\n\t      } else {\n\t        return false;\n\t      }\n\t    }\n\t\n\t    return true;\n\t  };\n\t\n\t  objectPath.ensureExists = function (obj, path, value){\n\t    return set(obj, path, value, true);\n\t  };\n\t\n\t  objectPath.set = function (obj, path, value, doNotReplace){\n\t    return set(obj, path, value, doNotReplace);\n\t  };\n\t\n\t  objectPath.insert = function (obj, path, value, at){\n\t    var arr = objectPath.get(obj, path);\n\t    at = ~~at;\n\t    if (!isArray(arr)) {\n\t      arr = [];\n\t      objectPath.set(obj, path, arr);\n\t    }\n\t    arr.splice(at, 0, value);\n\t  };\n\t\n\t  objectPath.empty = function(obj, path) {\n\t    if (isEmpty(path)) {\n\t      return obj;\n\t    }\n\t    if (isEmpty(obj)) {\n\t      return void 0;\n\t    }\n\t\n\t    var value, i;\n\t    if (!(value = objectPath.get(obj, path))) {\n\t      return obj;\n\t    }\n\t\n\t    if (isString(value)) {\n\t      return objectPath.set(obj, path, '');\n\t    } else if (isBoolean(value)) {\n\t      return objectPath.set(obj, path, false);\n\t    } else if (isNumber(value)) {\n\t      return objectPath.set(obj, path, 0);\n\t    } else if (isArray(value)) {\n\t      value.length = 0;\n\t    } else if (isObject(value)) {\n\t      for (i in value) {\n\t        if (_hasOwnProperty.call(value, i)) {\n\t          delete value[i];\n\t        }\n\t      }\n\t    } else {\n\t      return objectPath.set(obj, path, null);\n\t    }\n\t  };\n\t\n\t  objectPath.push = function (obj, path /*, values */){\n\t    var arr = objectPath.get(obj, path);\n\t    if (!isArray(arr)) {\n\t      arr = [];\n\t      objectPath.set(obj, path, arr);\n\t    }\n\t\n\t    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n\t  };\n\t\n\t  objectPath.coalesce = function (obj, paths, defaultValue) {\n\t    var value;\n\t\n\t    for (var i = 0, len = paths.length; i < len; i++) {\n\t      if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n\t        return value;\n\t      }\n\t    }\n\t\n\t    return defaultValue;\n\t  };\n\t\n\t  objectPath.get = function (obj, path, defaultValue){\n\t    if (isNumber(path)) {\n\t      path = [path];\n\t    }\n\t    if (isEmpty(path)) {\n\t      return obj;\n\t    }\n\t    if (isEmpty(obj)) {\n\t      return defaultValue;\n\t    }\n\t    if (isString(path)) {\n\t      return objectPath.get(obj, path.split('.'), defaultValue);\n\t    }\n\t\n\t    var currentPath = getKey(path[0]);\n\t\n\t    if (path.length === 1) {\n\t      if (obj[currentPath] === void 0) {\n\t        return defaultValue;\n\t      }\n\t      return obj[currentPath];\n\t    }\n\t\n\t    return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n\t  };\n\t\n\t  objectPath.del = function(obj, path) {\n\t    return del(obj, path);\n\t  };\n\t\n\t  return objectPath;\n\t});\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** redux-sync.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap c723f20f8d943aabbc9f\n **/","/**\n * # Index\n *\n *\n */\n\nexport syncStore from './store'\n\nexport default from './store'\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","\nvar Pipe = require('../pipe').Pipe;\n\nvar Context = function Context(){\n};\n\nContext.prototype.setResult = function(result) {\n\tthis.result = result;\n\tthis.hasResult = true;\n\treturn this;\n};\n\nContext.prototype.exit = function() {\n\tthis.exiting = true;\n\treturn this;\n};\n\nContext.prototype.switchTo = function(next, pipe) {\n\tif (typeof next === 'string' || next instanceof Pipe) {\n\t\tthis.nextPipe = next;\n\t} else {\n\t\tthis.next = next;\n\t\tif (pipe) {\n\t\t\tthis.nextPipe = pipe;\n\t\t}\n\t}\n\treturn this;\n};\n\nContext.prototype.push = function(child, name) {\n\tchild.parent = this;\n\tif (typeof name !== 'undefined') {\n\t\tchild.childName = name;\n\t}\n\tchild.root = this.root || this;\n\tchild.options = child.options || this.options;\n\tif (!this.children) {\n\t\tthis.children = [child];\n\t\tthis.nextAfterChildren = this.next || null;\n\t\tthis.next = child;\n\t} else {\n\t\tthis.children[this.children.length - 1].next = child;\n\t\tthis.children.push(child);\n\t}\n\tchild.next = this;\n\treturn this;\n};\n\nexports.Context = Context;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/context.js\n ** module id = 1\n ** module chunks = 0\n **/","var Context = require('./context').Context;\nvar dateReviver = require('../date-reviver');\n\nvar DiffContext = function DiffContext(left, right) {\n  this.left = left;\n  this.right = right;\n  this.pipe = 'diff';\n};\n\nDiffContext.prototype = new Context();\n\nDiffContext.prototype.setResult = function(result) {\n  if (this.options.cloneDiffValues) {\n    var clone = typeof this.options.cloneDiffValues === 'function' ?\n      this.options.cloneDiffValues : function(value) {\n        return JSON.parse(JSON.stringify(value), dateReviver);\n      };\n    if (typeof result[0] === 'object') {\n      result[0] = clone(result[0]);\n    }\n    if (typeof result[1] === 'object') {\n      result[1] = clone(result[1]);\n    }\n  }\n  return Context.prototype.setResult.apply(this, arguments);\n};\n\nexports.DiffContext = DiffContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/diff.js\n ** module id = 2\n ** module chunks = 0\n **/","var Context = require('./context').Context;\n\nvar PatchContext = function PatchContext(left, delta) {\n  this.left = left;\n  this.delta = delta;\n  this.pipe = 'patch';\n};\n\nPatchContext.prototype = new Context();\n\nexports.PatchContext = PatchContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/patch.js\n ** module id = 3\n ** module chunks = 0\n **/","var Context = require('./context').Context;\n\nvar ReverseContext = function ReverseContext(delta) {\n  this.delta = delta;\n  this.pipe = 'reverse';\n};\n\nReverseContext.prototype = new Context();\n\nexports.ReverseContext = ReverseContext;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/contexts/reverse.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * Diff Match and Patch\n *\n * Copyright 2006 Google Inc.\n * http://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Computes the difference between two texts to create a patch.\n * Applies the patch onto another text, allowing for errors.\n * @author fraser@google.com (Neil Fraser)\n */\n\n/**\n * Class containing the diff, match and patch methods.\n * @constructor\n */\nfunction diff_match_patch() {\n\n  // Defaults.\n  // Redefine these in your program to override the defaults.\n\n  // Number of seconds to map a diff before giving up (0 for infinity).\n  this.Diff_Timeout = 1.0;\n  // Cost of an empty edit operation in terms of edit characters.\n  this.Diff_EditCost = 4;\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\n  this.Match_Threshold = 0.5;\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\n  // A match this many characters away from the expected location will add\n  // 1.0 to the score (0.0 is a perfect match).\n  this.Match_Distance = 1000;\n  // When deleting a large block of text (over ~64 characters), how close does\n  // the contents have to match the expected contents. (0.0 = perfection,\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\n  // end points of a delete need to match.\n  this.Patch_DeleteThreshold = 0.5;\n  // Chunk size for context length.\n  this.Patch_Margin = 4;\n\n  // The number of bits in an int.\n  this.Match_MaxBits = 32;\n}\n\n\n//  DIFF FUNCTIONS\n\n\n/**\n * The data structure representing a diff is an array of tuples:\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n */\nvar DIFF_DELETE = -1;\nvar DIFF_INSERT = 1;\nvar DIFF_EQUAL = 0;\n\n/** @typedef {!Array.<number|string>} */\ndiff_match_patch.Diff;\n\n\n/**\n * Find the differences between two texts.  Simplifies the problem by stripping\n * any common prefix or suffix off the texts before diffing.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\n *     then don't run a line-level diff first to identify the changed areas.\n *     Defaults to true, which does a faster, slightly less optimal diff.\n * @param {number} opt_deadline Optional time when the diff should be complete\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\n *     instead.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\n    opt_deadline) {\n  // Set a deadline by which time the diff must be complete.\n  if (typeof opt_deadline == 'undefined') {\n    if (this.Diff_Timeout <= 0) {\n      opt_deadline = Number.MAX_VALUE;\n    } else {\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\n    }\n  }\n  var deadline = opt_deadline;\n\n  // Check for null inputs.\n  if (text1 == null || text2 == null) {\n    throw new Error('Null input. (diff_main)');\n  }\n\n  // Check for equality (speedup).\n  if (text1 == text2) {\n    if (text1) {\n      return [[DIFF_EQUAL, text1]];\n    }\n    return [];\n  }\n\n  if (typeof opt_checklines == 'undefined') {\n    opt_checklines = true;\n  }\n  var checklines = opt_checklines;\n\n  // Trim off common prefix (speedup).\n  var commonlength = this.diff_commonPrefix(text1, text2);\n  var commonprefix = text1.substring(0, commonlength);\n  text1 = text1.substring(commonlength);\n  text2 = text2.substring(commonlength);\n\n  // Trim off common suffix (speedup).\n  commonlength = this.diff_commonSuffix(text1, text2);\n  var commonsuffix = text1.substring(text1.length - commonlength);\n  text1 = text1.substring(0, text1.length - commonlength);\n  text2 = text2.substring(0, text2.length - commonlength);\n\n  // Compute the diff on the middle block.\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\n\n  // Restore the prefix and suffix.\n  if (commonprefix) {\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\n  }\n  if (commonsuffix) {\n    diffs.push([DIFF_EQUAL, commonsuffix]);\n  }\n  this.diff_cleanupMerge(diffs);\n  return diffs;\n};\n\n\n/**\n * Find the differences between two texts.  Assumes that the texts do not\n * have any common prefix or suffix.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\n *     line-level diff first to identify the changed areas.\n *     If true, then run a faster, slightly less optimal diff.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\n    deadline) {\n  var diffs;\n\n  if (!text1) {\n    // Just add some text (speedup).\n    return [[DIFF_INSERT, text2]];\n  }\n\n  if (!text2) {\n    // Just delete some text (speedup).\n    return [[DIFF_DELETE, text1]];\n  }\n\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  var i = longtext.indexOf(shorttext);\n  if (i != -1) {\n    // Shorter text is inside the longer text (speedup).\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\n             [DIFF_EQUAL, shorttext],\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\n    // Swap insertions for deletions if diff is reversed.\n    if (text1.length > text2.length) {\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\n    }\n    return diffs;\n  }\n\n  if (shorttext.length == 1) {\n    // Single character string.\n    // After the previous speedup, the character can't be an equality.\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n  }\n  longtext = shorttext = null;  // Garbage collect.\n\n  // Check to see if the problem can be split in two.\n  var hm = this.diff_halfMatch_(text1, text2);\n  if (hm) {\n    // A half-match was found, sort out the return data.\n    var text1_a = hm[0];\n    var text1_b = hm[1];\n    var text2_a = hm[2];\n    var text2_b = hm[3];\n    var mid_common = hm[4];\n    // Send both pairs off for separate processing.\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\n    // Merge the results.\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\n  }\n\n  if (checklines && text1.length > 100 && text2.length > 100) {\n    return this.diff_lineMode_(text1, text2, deadline);\n  }\n\n  return this.diff_bisect_(text1, text2, deadline);\n};\n\n\n/**\n * Do a quick line-level diff on both strings, then rediff the parts for\n * greater accuracy.\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time when the diff should be complete by.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\n  // Scan the text on a line-by-line basis first.\n  var a = this.diff_linesToChars_(text1, text2);\n  text1 = /** @type {string} */(a[0]);\n  text2 = /** @type {string} */(a[1]);\n  var linearray = /** @type {!Array.<string>} */(a[2]);\n\n  var diffs = this.diff_bisect_(text1, text2, deadline);\n\n  // Convert the diff back to original text.\n  this.diff_charsToLines_(diffs, linearray);\n  // Eliminate freak matches (e.g. blank lines)\n  this.diff_cleanupSemantic(diffs);\n\n  // Rediff any replacement blocks, this time character-by-character.\n  // Add a dummy entry at the end.\n  diffs.push([DIFF_EQUAL, '']);\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete >= 1 && count_insert >= 1) {\n          // Delete the offending records and add the merged ones.\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\n          diffs.splice(pointer - count_delete - count_insert,\n                       count_delete + count_insert);\n          pointer = pointer - count_delete - count_insert;\n          for (var j = a.length - 1; j >= 0; j--) {\n            diffs.splice(pointer, 0, a[j]);\n          }\n          pointer = pointer + a.length;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n    pointer++;\n  }\n  diffs.pop();  // Remove the dummy entry at the end.\n\n  return diffs;\n};\n\n\n/**\n * Find the 'middle snake' of a diff, split the problem in two\n * and return the recursively constructed diff.\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\n  var v_offset = max_d;\n  var v_length = 2 * max_d;\n  var v1 = new Array(v_length);\n  var v2 = new Array(v_length);\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\n  // integers and undefined.\n  for (var x = 0; x < v_length; x++) {\n    v1[x] = -1;\n    v2[x] = -1;\n  }\n  v1[v_offset + 1] = 0;\n  v2[v_offset + 1] = 0;\n  var delta = text1_length - text2_length;\n  // If the total number of characters is odd, then the front path will collide\n  // with the reverse path.\n  var front = (delta % 2 != 0);\n  // Offsets for start and end of k loop.\n  // Prevents mapping of space beyond the grid.\n  var k1start = 0;\n  var k1end = 0;\n  var k2start = 0;\n  var k2end = 0;\n  for (var d = 0; d < max_d; d++) {\n    // Bail out if deadline is reached.\n    if ((new Date()).getTime() > deadline) {\n      break;\n    }\n\n    // Walk the front path one step.\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\n      var k1_offset = v_offset + k1;\n      var x1;\n      if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {\n        x1 = v1[k1_offset + 1];\n      } else {\n        x1 = v1[k1_offset - 1] + 1;\n      }\n      var y1 = x1 - k1;\n      while (x1 < text1_length && y1 < text2_length &&\n             text1.charAt(x1) == text2.charAt(y1)) {\n        x1++;\n        y1++;\n      }\n      v1[k1_offset] = x1;\n      if (x1 > text1_length) {\n        // Ran off the right of the graph.\n        k1end += 2;\n      } else if (y1 > text2_length) {\n        // Ran off the bottom of the graph.\n        k1start += 2;\n      } else if (front) {\n        var k2_offset = v_offset + delta - k1;\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\n          // Mirror x2 onto top-left coordinate system.\n          var x2 = text1_length - v2[k2_offset];\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n\n    // Walk the reverse path one step.\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\n      var k2_offset = v_offset + k2;\n      var x2;\n      if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {\n        x2 = v2[k2_offset + 1];\n      } else {\n        x2 = v2[k2_offset - 1] + 1;\n      }\n      var y2 = x2 - k2;\n      while (x2 < text1_length && y2 < text2_length &&\n             text1.charAt(text1_length - x2 - 1) ==\n             text2.charAt(text2_length - y2 - 1)) {\n        x2++;\n        y2++;\n      }\n      v2[k2_offset] = x2;\n      if (x2 > text1_length) {\n        // Ran off the left of the graph.\n        k2end += 2;\n      } else if (y2 > text2_length) {\n        // Ran off the top of the graph.\n        k2start += 2;\n      } else if (!front) {\n        var k1_offset = v_offset + delta - k2;\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\n          var x1 = v1[k1_offset];\n          var y1 = v_offset + x1 - k1_offset;\n          // Mirror x2 onto top-left coordinate system.\n          x2 = text1_length - x2;\n          if (x1 >= x2) {\n            // Overlap detected.\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\n          }\n        }\n      }\n    }\n  }\n  // Diff took too long and hit the deadline or\n  // number of diffs equals number of characters, no commonality at all.\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\n};\n\n\n/**\n * Given the location of the 'middle snake', split the diff in two parts\n * and recurse.\n * @param {string} text1 Old string to be diffed.\n * @param {string} text2 New string to be diffed.\n * @param {number} x Index of split point in text1.\n * @param {number} y Index of split point in text2.\n * @param {number} deadline Time at which to bail if not yet complete.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @private\n */\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\n    deadline) {\n  var text1a = text1.substring(0, x);\n  var text2a = text2.substring(0, y);\n  var text1b = text1.substring(x);\n  var text2b = text2.substring(y);\n\n  // Compute both diffs serially.\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\n\n  return diffs.concat(diffsb);\n};\n\n\n/**\n * Split two texts into an array of strings.  Reduce the texts to a string of\n * hashes where each Unicode character represents one line.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {!Array.<string|!Array.<string>>} Three element Array, containing the\n *     encoded text1, the encoded text2 and the array of unique strings.  The\n *     zeroth element of the array of unique strings is intentionally blank.\n * @private\n */\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\n\n  // '\\x00' is a valid character, but various debuggers don't like it.\n  // So we'll insert a junk entry to avoid generating a null character.\n  lineArray[0] = '';\n\n  /**\n   * Split a text into an array of strings.  Reduce the texts to a string of\n   * hashes where each Unicode character represents one line.\n   * Modifies linearray and linehash through being a closure.\n   * @param {string} text String to encode.\n   * @return {string} Encoded string.\n   * @private\n   */\n  function diff_linesToCharsMunge_(text) {\n    var chars = '';\n    // Walk the text, pulling out a substring for each line.\n    // text.split('\\n') would would temporarily double our memory footprint.\n    // Modifying text would create many large strings to garbage collect.\n    var lineStart = 0;\n    var lineEnd = -1;\n    // Keeping our own length variable is faster than looking it up.\n    var lineArrayLength = lineArray.length;\n    while (lineEnd < text.length - 1) {\n      lineEnd = text.indexOf('\\n', lineStart);\n      if (lineEnd == -1) {\n        lineEnd = text.length - 1;\n      }\n      var line = text.substring(lineStart, lineEnd + 1);\n      lineStart = lineEnd + 1;\n\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\n          (lineHash[line] !== undefined)) {\n        chars += String.fromCharCode(lineHash[line]);\n      } else {\n        chars += String.fromCharCode(lineArrayLength);\n        lineHash[line] = lineArrayLength;\n        lineArray[lineArrayLength++] = line;\n      }\n    }\n    return chars;\n  }\n\n  var chars1 = diff_linesToCharsMunge_(text1);\n  var chars2 = diff_linesToCharsMunge_(text2);\n  return [chars1, chars2, lineArray];\n};\n\n\n/**\n * Rehydrate the text in a diff from a string of line hashes to real lines of\n * text.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {!Array.<string>} lineArray Array of unique strings.\n * @private\n */\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\n  for (var x = 0; x < diffs.length; x++) {\n    var chars = diffs[x][1];\n    var text = [];\n    for (var y = 0; y < chars.length; y++) {\n      text[y] = lineArray[chars.charCodeAt(y)];\n    }\n    diffs[x][1] = text.join('');\n  }\n};\n\n\n/**\n * Determine the common prefix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the start of each\n *     string.\n */\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerstart = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(pointerstart, pointermid) ==\n        text2.substring(pointerstart, pointermid)) {\n      pointermin = pointermid;\n      pointerstart = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine the common suffix of two strings.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of each string.\n */\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\n  // Quick check for common null cases.\n  if (!text1 || !text2 ||\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\n    return 0;\n  }\n  // Binary search.\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\n  var pointermin = 0;\n  var pointermax = Math.min(text1.length, text2.length);\n  var pointermid = pointermax;\n  var pointerend = 0;\n  while (pointermin < pointermid) {\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\n      pointermin = pointermid;\n      pointerend = pointermin;\n    } else {\n      pointermax = pointermid;\n    }\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\n  }\n  return pointermid;\n};\n\n\n/**\n * Determine if the suffix of one string is the prefix of another.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {number} The number of characters common to the end of the first\n *     string and the start of the second string.\n * @private\n */\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\n  // Cache the text lengths to prevent multiple calls.\n  var text1_length = text1.length;\n  var text2_length = text2.length;\n  // Eliminate the null case.\n  if (text1_length == 0 || text2_length == 0) {\n    return 0;\n  }\n  // Truncate the longer string.\n  if (text1_length > text2_length) {\n    text1 = text1.substring(text1_length - text2_length);\n  } else if (text1_length < text2_length) {\n    text2 = text2.substring(0, text1_length);\n  }\n  var text_length = Math.min(text1_length, text2_length);\n  // Quick check for the worst case.\n  if (text1 == text2) {\n    return text_length;\n  }\n\n  // Start by looking for a single character match\n  // and increase length until no match is found.\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\n  var best = 0;\n  var length = 1;\n  while (true) {\n    var pattern = text1.substring(text_length - length);\n    var found = text2.indexOf(pattern);\n    if (found == -1) {\n      return best;\n    }\n    length += found;\n    if (found == 0 || text1.substring(text_length - length) ==\n        text2.substring(0, length)) {\n      best = length;\n      length++;\n    }\n  }\n};\n\n\n/**\n * Do the two texts share a substring which is at least half the length of the\n * longer text?\n * This speedup can produce non-minimal diffs.\n * @param {string} text1 First string.\n * @param {string} text2 Second string.\n * @return {Array.<string>} Five element Array, containing the prefix of\n *     text1, the suffix of text1, the prefix of text2, the suffix of\n *     text2 and the common middle.  Or null if there was no match.\n * @private\n */\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\n  if (this.Diff_Timeout <= 0) {\n    // Don't risk returning a non-optimal diff if we have unlimited time.\n    return null;\n  }\n  var longtext = text1.length > text2.length ? text1 : text2;\n  var shorttext = text1.length > text2.length ? text2 : text1;\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\n    return null;  // Pointless.\n  }\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Does a substring of shorttext exist within longtext such that the substring\n   * is at least half the length of longtext?\n   * Closure, but does not reference any external variables.\n   * @param {string} longtext Longer string.\n   * @param {string} shorttext Shorter string.\n   * @param {number} i Start index of quarter length substring within longtext.\n   * @return {Array.<string>} Five element Array, containing the prefix of\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n   *     of shorttext and the common middle.  Or null if there was no match.\n   * @private\n   */\n  function diff_halfMatchI_(longtext, shorttext, i) {\n    // Start with a 1/4 length substring at position i as a seed.\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\n    var j = -1;\n    var best_common = '';\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\n                                               shorttext.substring(j));\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\n                                               shorttext.substring(0, j));\n      if (best_common.length < suffixLength + prefixLength) {\n        best_common = shorttext.substring(j - suffixLength, j) +\n            shorttext.substring(j, j + prefixLength);\n        best_longtext_a = longtext.substring(0, i - suffixLength);\n        best_longtext_b = longtext.substring(i + prefixLength);\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\n        best_shorttext_b = shorttext.substring(j + prefixLength);\n      }\n    }\n    if (best_common.length * 2 >= longtext.length) {\n      return [best_longtext_a, best_longtext_b,\n              best_shorttext_a, best_shorttext_b, best_common];\n    } else {\n      return null;\n    }\n  }\n\n  // First check if the second quarter is the seed for a half-match.\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 4));\n  // Check again based on the third quarter.\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\n                             Math.ceil(longtext.length / 2));\n  var hm;\n  if (!hm1 && !hm2) {\n    return null;\n  } else if (!hm2) {\n    hm = hm1;\n  } else if (!hm1) {\n    hm = hm2;\n  } else {\n    // Both matched.  Select the longest.\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\n  }\n\n  // A half-match was found, sort out the return data.\n  var text1_a, text1_b, text2_a, text2_b;\n  if (text1.length > text2.length) {\n    text1_a = hm[0];\n    text1_b = hm[1];\n    text2_a = hm[2];\n    text2_b = hm[3];\n  } else {\n    text2_a = hm[0];\n    text2_b = hm[1];\n    text1_a = hm[2];\n    text1_b = hm[3];\n  }\n  var mid_common = hm[4];\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\n};\n\n\n/**\n * Reduce the number of edits by eliminating semantically trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  /** @type {?string} */\n  var lastequality = null;  // Always equal to equalities[equalitiesLength-1][1]\n  var pointer = 0;  // Index of current position.\n  // Number of characters that changed prior to the equality.\n  var length_insertions1 = 0;\n  var length_deletions1 = 0;\n  // Number of characters that changed after the equality.\n  var length_insertions2 = 0;\n  var length_deletions2 = 0;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      equalities[equalitiesLength++] = pointer;\n      length_insertions1 = length_insertions2;\n      length_deletions1 = length_deletions2;\n      length_insertions2 = 0;\n      length_deletions2 = 0;\n      lastequality = /** @type {string} */(diffs[pointer][1]);\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_INSERT) {\n        length_insertions2 += diffs[pointer][1].length;\n      } else {\n        length_deletions2 += diffs[pointer][1].length;\n      }\n      // Eliminate an equality that is smaller or equal to the edits on both\n      // sides of it.\n      if (lastequality !== null && (lastequality.length <=\n          Math.max(length_insertions1, length_deletions1)) &&\n          (lastequality.length <= Math.max(length_insertions2,\n                                           length_deletions2))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        // Throw away the equality we just deleted.\n        equalitiesLength--;\n        // Throw away the previous equality (it needs to be reevaluated).\n        equalitiesLength--;\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\n        length_insertions1 = 0;  // Reset the counters.\n        length_deletions1 = 0;\n        length_insertions2 = 0;\n        length_deletions2 = 0;\n        lastequality = null;\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  // Normalize the diff.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n  this.diff_cleanupSemanticLossless(diffs);\n\n  // Find any overlaps between deletions and insertions.\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\n  //   -> <del>abc</del>xxx<ins>def</ins>\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\n  pointer = 1;\n  while (pointer < diffs.length) {\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\n        diffs[pointer][0] == DIFF_INSERT) {\n      var deletion = /** @type {string} */(diffs[pointer - 1][1]);\n      var insertion = /** @type {string} */(diffs[pointer][1]);\n      var overlap_length = this.diff_commonOverlap_(deletion, insertion);\n      if (overlap_length >= deletion.length / 2 ||\n          overlap_length >= insertion.length / 2) {\n        // Overlap found.  Insert an equality and trim the surrounding edits.\n        diffs.splice(pointer, 0,\n            [DIFF_EQUAL, insertion.substring(0, overlap_length)]);\n        diffs[pointer - 1][1] =\n            deletion.substring(0, deletion.length - overlap_length);\n        diffs[pointer + 1][1] = insertion.substring(overlap_length);\n        pointer++;\n      }\n      pointer++;\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Look for single edits surrounded on both sides by equalities\n * which can be shifted sideways to align the edit to a word boundary.\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\n  // Define some regex patterns for matching boundaries.\n  var punctuation = /[^a-zA-Z0-9]/;\n  var whitespace = /\\s/;\n  var linebreak = /[\\r\\n]/;\n  var blanklineEnd = /\\n\\r?\\n$/;\n  var blanklineStart = /^\\r?\\n\\r?\\n/;\n\n  /**\n   * Given two strings, compute a score representing whether the internal\n   * boundary falls on logical boundaries.\n   * Scores range from 5 (best) to 0 (worst).\n   * Closure, makes reference to regex patterns defined above.\n   * @param {string} one First string.\n   * @param {string} two Second string.\n   * @return {number} The score.\n   * @private\n   */\n  function diff_cleanupSemanticScore_(one, two) {\n    if (!one || !two) {\n      // Edges are the best.\n      return 5;\n    }\n\n    // Each port of this function behaves slightly differently due to\n    // subtle differences in each language's definition of things like\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\n    // the choice has been made to use each language's native features\n    // rather than force total conformity.\n    var score = 0;\n    // One point for non-alphanumeric.\n    if (one.charAt(one.length - 1).match(punctuation) ||\n        two.charAt(0).match(punctuation)) {\n      score++;\n      // Two points for whitespace.\n      if (one.charAt(one.length - 1).match(whitespace) ||\n          two.charAt(0).match(whitespace)) {\n        score++;\n        // Three points for line breaks.\n        if (one.charAt(one.length - 1).match(linebreak) ||\n            two.charAt(0).match(linebreak)) {\n          score++;\n          // Four points for blank lines.\n          if (one.match(blanklineEnd) || two.match(blanklineStart)) {\n            score++;\n          }\n        }\n      }\n    }\n    return score;\n  }\n\n  var pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      var equality1 = /** @type {string} */(diffs[pointer - 1][1]);\n      var edit = /** @type {string} */(diffs[pointer][1]);\n      var equality2 = /** @type {string} */(diffs[pointer + 1][1]);\n\n      // First, shift the edit as far left as possible.\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\n      if (commonOffset) {\n        var commonString = edit.substring(edit.length - commonOffset);\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\n        equality2 = commonString + equality2;\n      }\n\n      // Second, step character by character right, looking for the best fit.\n      var bestEquality1 = equality1;\n      var bestEdit = edit;\n      var bestEquality2 = equality2;\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\n          diff_cleanupSemanticScore_(edit, equality2);\n      while (edit.charAt(0) === equality2.charAt(0)) {\n        equality1 += edit.charAt(0);\n        edit = edit.substring(1) + equality2.charAt(0);\n        equality2 = equality2.substring(1);\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\n            diff_cleanupSemanticScore_(edit, equality2);\n        // The >= encourages trailing rather than leading whitespace on edits.\n        if (score >= bestScore) {\n          bestScore = score;\n          bestEquality1 = equality1;\n          bestEdit = edit;\n          bestEquality2 = equality2;\n        }\n      }\n\n      if (diffs[pointer - 1][1] != bestEquality1) {\n        // We have an improvement, save it back to the diff.\n        if (bestEquality1) {\n          diffs[pointer - 1][1] = bestEquality1;\n        } else {\n          diffs.splice(pointer - 1, 1);\n          pointer--;\n        }\n        diffs[pointer][1] = bestEdit;\n        if (bestEquality2) {\n          diffs[pointer + 1][1] = bestEquality2;\n        } else {\n          diffs.splice(pointer + 1, 1);\n          pointer--;\n        }\n      }\n    }\n    pointer++;\n  }\n};\n\n\n/**\n * Reduce the number of edits by eliminating operationally trivial equalities.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\n  var changes = false;\n  var equalities = [];  // Stack of indices where equalities are found.\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\n  var lastequality = '';  // Always equal to equalities[equalitiesLength-1][1]\n  var pointer = 0;  // Index of current position.\n  // Is there an insertion operation before the last equality.\n  var pre_ins = false;\n  // Is there a deletion operation before the last equality.\n  var pre_del = false;\n  // Is there an insertion operation after the last equality.\n  var post_ins = false;\n  // Is there a deletion operation after the last equality.\n  var post_del = false;\n  while (pointer < diffs.length) {\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\n          (post_ins || post_del)) {\n        // Candidate found.\n        equalities[equalitiesLength++] = pointer;\n        pre_ins = post_ins;\n        pre_del = post_del;\n        lastequality = diffs[pointer][1];\n      } else {\n        // Not a candidate, and can never become one.\n        equalitiesLength = 0;\n        lastequality = '';\n      }\n      post_ins = post_del = false;\n    } else {  // An insertion or deletion.\n      if (diffs[pointer][0] == DIFF_DELETE) {\n        post_del = true;\n      } else {\n        post_ins = true;\n      }\n      /*\n       * Five types to be split:\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\n       * <ins>A</del>X<ins>C</ins><del>D</del>\n       * <ins>A</ins><del>B</del>X<del>C</del>\n       */\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\n        // Duplicate record.\n        diffs.splice(equalities[equalitiesLength - 1], 0,\n                     [DIFF_DELETE, lastequality]);\n        // Change second copy to insert.\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\n        equalitiesLength--;  // Throw away the equality we just deleted;\n        lastequality = '';\n        if (pre_ins && pre_del) {\n          // No changes made which could affect previous entry, keep going.\n          post_ins = post_del = true;\n          equalitiesLength = 0;\n        } else {\n          equalitiesLength--;  // Throw away the previous equality.\n          pointer = equalitiesLength > 0 ?\n              equalities[equalitiesLength - 1] : -1;\n          post_ins = post_del = false;\n        }\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * Reorder and merge like edit sections.  Merge equalities.\n * Any edit section can move as long as it doesn't cross an equality.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n */\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\n  var pointer = 0;\n  var count_delete = 0;\n  var count_insert = 0;\n  var text_delete = '';\n  var text_insert = '';\n  var commonlength;\n  while (pointer < diffs.length) {\n    switch (diffs[pointer][0]) {\n      case DIFF_INSERT:\n        count_insert++;\n        text_insert += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_DELETE:\n        count_delete++;\n        text_delete += diffs[pointer][1];\n        pointer++;\n        break;\n      case DIFF_EQUAL:\n        // Upon reaching an equality, check for prior redundancies.\n        if (count_delete + count_insert > 1) {\n          if (count_delete !== 0 && count_insert !== 0) {\n            // Factor out any common prefixies.\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              if ((pointer - count_delete - count_insert) > 0 &&\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\n                  DIFF_EQUAL) {\n                diffs[pointer - count_delete - count_insert - 1][1] +=\n                    text_insert.substring(0, commonlength);\n              } else {\n                diffs.splice(0, 0, [DIFF_EQUAL,\n                                    text_insert.substring(0, commonlength)]);\n                pointer++;\n              }\n              text_insert = text_insert.substring(commonlength);\n              text_delete = text_delete.substring(commonlength);\n            }\n            // Factor out any common suffixies.\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\n            if (commonlength !== 0) {\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\n                  commonlength) + diffs[pointer][1];\n              text_insert = text_insert.substring(0, text_insert.length -\n                  commonlength);\n              text_delete = text_delete.substring(0, text_delete.length -\n                  commonlength);\n            }\n          }\n          // Delete the offending records and add the merged ones.\n          if (count_delete === 0) {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\n          } else if (count_insert === 0) {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\n          } else {\n            diffs.splice(pointer - count_delete - count_insert,\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\n                [DIFF_INSERT, text_insert]);\n          }\n          pointer = pointer - count_delete - count_insert +\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\n          // Merge this equality with the previous one.\n          diffs[pointer - 1][1] += diffs[pointer][1];\n          diffs.splice(pointer, 1);\n        } else {\n          pointer++;\n        }\n        count_insert = 0;\n        count_delete = 0;\n        text_delete = '';\n        text_insert = '';\n        break;\n    }\n  }\n  if (diffs[diffs.length - 1][1] === '') {\n    diffs.pop();  // Remove the dummy entry at the end.\n  }\n\n  // Second pass: look for single edits surrounded on both sides by equalities\n  // which can be shifted sideways to eliminate an equality.\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n  var changes = false;\n  pointer = 1;\n  // Intentionally ignore the first and last element (don't need checking).\n  while (pointer < diffs.length - 1) {\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\n      // This is a single edit surrounded by equalities.\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\n        // Shift the edit over the previous equality.\n        diffs[pointer][1] = diffs[pointer - 1][1] +\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\n                                        diffs[pointer - 1][1].length);\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\n        diffs.splice(pointer - 1, 1);\n        changes = true;\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\n          diffs[pointer + 1][1]) {\n        // Shift the edit over the next equality.\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\n        diffs[pointer][1] =\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\n            diffs[pointer + 1][1];\n        diffs.splice(pointer + 1, 1);\n        changes = true;\n      }\n    }\n    pointer++;\n  }\n  // If shifts were made, the diff needs reordering and another shift sweep.\n  if (changes) {\n    this.diff_cleanupMerge(diffs);\n  }\n};\n\n\n/**\n * loc is a location in text1, compute and return the equivalent location in\n * text2.\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @param {number} loc Location within text1.\n * @return {number} Location within text2.\n */\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\n  var chars1 = 0;\n  var chars2 = 0;\n  var last_chars1 = 0;\n  var last_chars2 = 0;\n  var x;\n  for (x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\n      chars1 += diffs[x][1].length;\n    }\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\n      chars2 += diffs[x][1].length;\n    }\n    if (chars1 > loc) {  // Overshot the location.\n      break;\n    }\n    last_chars1 = chars1;\n    last_chars2 = chars2;\n  }\n  // Was the location was deleted?\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\n    return last_chars2;\n  }\n  // Add the remaining character length.\n  return last_chars2 + (loc - last_chars1);\n};\n\n\n/**\n * Convert a diff array into a pretty HTML report.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} HTML representation.\n */\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\n  var html = [];\n  var i = 0;\n  var pattern_amp = /&/g;\n  var pattern_lt = /</g;\n  var pattern_gt = />/g;\n  var pattern_para = /\\n/g;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\n    var data = diffs[x][1];  // Text of change.\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\n    switch (op) {\n      case DIFF_INSERT:\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\n        break;\n      case DIFF_DELETE:\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\n        break;\n      case DIFF_EQUAL:\n        html[x] = '<span>' + text + '</span>';\n        break;\n    }\n    if (op !== DIFF_DELETE) {\n      i += data.length;\n    }\n  }\n  return html.join('');\n};\n\n\n/**\n * Compute and return the source text (all equalities and deletions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Source text.\n */\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_INSERT) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute and return the destination text (all equalities and insertions).\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Destination text.\n */\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    if (diffs[x][0] !== DIFF_DELETE) {\n      text[x] = diffs[x][1];\n    }\n  }\n  return text.join('');\n};\n\n\n/**\n * Compute the Levenshtein distance; the number of inserted, deleted or\n * substituted characters.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {number} Number of changes.\n */\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\n  var levenshtein = 0;\n  var insertions = 0;\n  var deletions = 0;\n  for (var x = 0; x < diffs.length; x++) {\n    var op = diffs[x][0];\n    var data = diffs[x][1];\n    switch (op) {\n      case DIFF_INSERT:\n        insertions += data.length;\n        break;\n      case DIFF_DELETE:\n        deletions += data.length;\n        break;\n      case DIFF_EQUAL:\n        // A deletion and an insertion is one substitution.\n        levenshtein += Math.max(insertions, deletions);\n        insertions = 0;\n        deletions = 0;\n        break;\n    }\n  }\n  levenshtein += Math.max(insertions, deletions);\n  return levenshtein;\n};\n\n\n/**\n * Crush the diff into an encoded string which describes the operations\n * required to transform text1 into text2.\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\n * @return {string} Delta text.\n */\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\n  var text = [];\n  for (var x = 0; x < diffs.length; x++) {\n    switch (diffs[x][0]) {\n      case DIFF_INSERT:\n        text[x] = '+' + encodeURI(diffs[x][1]);\n        break;\n      case DIFF_DELETE:\n        text[x] = '-' + diffs[x][1].length;\n        break;\n      case DIFF_EQUAL:\n        text[x] = '=' + diffs[x][1].length;\n        break;\n    }\n  }\n  return text.join('\\t').replace(/%20/g, ' ');\n};\n\n\n/**\n * Given the original text1, and an encoded string which describes the\n * operations required to transform text1 into text2, compute the full diff.\n * @param {string} text1 Source string for the diff.\n * @param {string} delta Delta text.\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\n  var diffs = [];\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\n  var pointer = 0;  // Cursor in text1\n  var tokens = delta.split(/\\t/g);\n  for (var x = 0; x < tokens.length; x++) {\n    // Each token begins with a one character parameter which specifies the\n    // operation of this token (delete, insert, equality).\n    var param = tokens[x].substring(1);\n    switch (tokens[x].charAt(0)) {\n      case '+':\n        try {\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\n        } catch (ex) {\n          // Malformed URI sequence.\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\n        }\n        break;\n      case '-':\n        // Fall through.\n      case '=':\n        var n = parseInt(param, 10);\n        if (isNaN(n) || n < 0) {\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\n        }\n        var text = text1.substring(pointer, pointer += n);\n        if (tokens[x].charAt(0) == '=') {\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\n        } else {\n          diffs[diffsLength++] = [DIFF_DELETE, text];\n        }\n        break;\n      default:\n        // Blank tokens are ok (from a trailing \\t).\n        // Anything else is an error.\n        if (tokens[x]) {\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\n                          tokens[x]);\n        }\n    }\n  }\n  if (pointer != text1.length) {\n    throw new Error('Delta length (' + pointer +\n        ') does not equal source text length (' + text1.length + ').');\n  }\n  return diffs;\n};\n\n\n//  MATCH FUNCTIONS\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n */\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\n  // Check for null inputs.\n  if (text == null || pattern == null || loc == null) {\n    throw new Error('Null input. (match_main)');\n  }\n\n  loc = Math.max(0, Math.min(loc, text.length));\n  if (text == pattern) {\n    // Shortcut (potentially not guaranteed by the algorithm)\n    return 0;\n  } else if (!text.length) {\n    // Nothing to match.\n    return -1;\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\n    return loc;\n  } else {\n    // Do a fuzzy compare.\n    return this.match_bitap_(text, pattern, loc);\n  }\n};\n\n\n/**\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\n * Bitap algorithm.\n * @param {string} text The text to search.\n * @param {string} pattern The pattern to search for.\n * @param {number} loc The location to search around.\n * @return {number} Best match index or -1.\n * @private\n */\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\n  if (pattern.length > this.Match_MaxBits) {\n    throw new Error('Pattern too long for this browser.');\n  }\n\n  // Initialise the alphabet.\n  var s = this.match_alphabet_(pattern);\n\n  var dmp = this;  // 'this' becomes 'window' in a closure.\n\n  /**\n   * Compute and return the score for a match with e errors and x location.\n   * Accesses loc and pattern through being a closure.\n   * @param {number} e Number of errors in match.\n   * @param {number} x Location of match.\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\n   * @private\n   */\n  function match_bitapScore_(e, x) {\n    var accuracy = e / pattern.length;\n    var proximity = Math.abs(loc - x);\n    if (!dmp.Match_Distance) {\n      // Dodge divide by zero error.\n      return proximity ? 1.0 : accuracy;\n    }\n    return accuracy + (proximity / dmp.Match_Distance);\n  }\n\n  // Highest score beyond which we give up.\n  var score_threshold = this.Match_Threshold;\n  // Is there a nearby exact match? (speedup)\n  var best_loc = text.indexOf(pattern, loc);\n  if (best_loc != -1) {\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    // What about in the other direction? (speedup)\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\n    if (best_loc != -1) {\n      score_threshold =\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\n    }\n  }\n\n  // Initialise the bit arrays.\n  var matchmask = 1 << (pattern.length - 1);\n  best_loc = -1;\n\n  var bin_min, bin_mid;\n  var bin_max = pattern.length + text.length;\n  var last_rd;\n  for (var d = 0; d < pattern.length; d++) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from 'loc' we can stray at this\n    // error level.\n    bin_min = 0;\n    bin_mid = bin_max;\n    while (bin_min < bin_mid) {\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\n        bin_min = bin_mid;\n      } else {\n        bin_max = bin_mid;\n      }\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\n    }\n    // Use the result from this iteration as the maximum for the next.\n    bin_max = bin_mid;\n    var start = Math.max(1, loc - bin_mid + 1);\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\n\n    var rd = Array(finish + 2);\n    rd[finish + 1] = (1 << d) - 1;\n    for (var j = finish; j >= start; j--) {\n      // The alphabet (s) is a sparse hash, so the following line generates\n      // warnings.\n      var charMatch = s[text.charAt(j - 1)];\n      if (d === 0) {  // First pass: exact match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\n      } else {  // Subsequent passes: fuzzy match.\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch |\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\n                last_rd[j + 1];\n      }\n      if (rd[j] & matchmask) {\n        var score = match_bitapScore_(d, j - 1);\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (score <= score_threshold) {\n          // Told you so.\n          score_threshold = score;\n          best_loc = j - 1;\n          if (best_loc > loc) {\n            // When passing loc, don't exceed our current distance from loc.\n            start = Math.max(1, 2 * loc - best_loc);\n          } else {\n            // Already passed loc, downhill from here on in.\n            break;\n          }\n        }\n      }\n    }\n    // No hope for a (better) match at greater error levels.\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\n      break;\n    }\n    last_rd = rd;\n  }\n  return best_loc;\n};\n\n\n/**\n * Initialise the alphabet for the Bitap algorithm.\n * @param {string} pattern The text to encode.\n * @return {!Object} Hash of character locations.\n * @private\n */\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\n  var s = {};\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] = 0;\n  }\n  for (var i = 0; i < pattern.length; i++) {\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\n  }\n  return s;\n};\n\n\n//  PATCH FUNCTIONS\n\n\n/**\n * Increase the context until it is unique,\n * but don't let the pattern expand beyond Match_MaxBits.\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\n * @param {string} text Source text.\n * @private\n */\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\n  if (text.length == 0) {\n    return;\n  }\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\n  var padding = 0;\n\n  // Look for the first and last matches of pattern in text.  If two different\n  // matches are found, increase the pattern length.\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\n         this.Patch_Margin) {\n    padding += this.Patch_Margin;\n    pattern = text.substring(patch.start2 - padding,\n                             patch.start2 + patch.length1 + padding);\n  }\n  // Add one chunk for good luck.\n  padding += this.Patch_Margin;\n\n  // Add the prefix.\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\n  if (prefix) {\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\n  }\n  // Add the suffix.\n  var suffix = text.substring(patch.start2 + patch.length1,\n                              patch.start2 + patch.length1 + padding);\n  if (suffix) {\n    patch.diffs.push([DIFF_EQUAL, suffix]);\n  }\n\n  // Roll back the start points.\n  patch.start1 -= prefix.length;\n  patch.start2 -= prefix.length;\n  // Extend the lengths.\n  patch.length1 += prefix.length + suffix.length;\n  patch.length2 += prefix.length + suffix.length;\n};\n\n\n/**\n * Compute a list of patches to turn text1 into text2.\n * Use diffs if provided, otherwise compute it ourselves.\n * There are four ways to call this function, depending on what data is\n * available to the caller:\n * Method 1:\n * a = text1, b = text2\n * Method 2:\n * a = diffs\n * Method 3 (optimal):\n * a = text1, b = diffs\n * Method 4 (deprecated, use method 3):\n * a = text1, b = text2, c = diffs\n *\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\n * Array of diff tuples for text1 to text2 (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n */\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\n  var text1, diffs;\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\n      typeof opt_c == 'undefined') {\n    // Method 1: text1, text2\n    // Compute diffs from text1 and text2.\n    text1 = /** @type {string} */(a);\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\n    if (diffs.length > 2) {\n      this.diff_cleanupSemantic(diffs);\n      this.diff_cleanupEfficiency(diffs);\n    }\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\n      typeof opt_c == 'undefined') {\n    // Method 2: diffs\n    // Compute text1 from diffs.\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\n    text1 = this.diff_text1(diffs);\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\n      typeof opt_c == 'undefined') {\n    // Method 3: text1, diffs\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\n      opt_c && typeof opt_c == 'object') {\n    // Method 4: text1, text2, diffs\n    // text2 is not used.\n    text1 = /** @type {string} */(a);\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\n  } else {\n    throw new Error('Unknown call format to patch_make.');\n  }\n\n  if (diffs.length === 0) {\n    return [];  // Get rid of the null case.\n  }\n  var patches = [];\n  var patch = new diff_match_patch.patch_obj();\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\n  var char_count1 = 0;  // Number of characters into the text1 string.\n  var char_count2 = 0;  // Number of characters into the text2 string.\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\n  // context info.\n  var prepatch_text = text1;\n  var postpatch_text = text1;\n  for (var x = 0; x < diffs.length; x++) {\n    var diff_type = diffs[x][0];\n    var diff_text = diffs[x][1];\n\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\n      // A new patch starts here.\n      patch.start1 = char_count1;\n      patch.start2 = char_count2;\n    }\n\n    switch (diff_type) {\n      case DIFF_INSERT:\n        patch.diffs[patchDiffLength++] = diffs[x];\n        patch.length2 += diff_text.length;\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\n                         postpatch_text.substring(char_count2);\n        break;\n      case DIFF_DELETE:\n        patch.length1 += diff_text.length;\n        patch.diffs[patchDiffLength++] = diffs[x];\n        postpatch_text = postpatch_text.substring(0, char_count2) +\n                         postpatch_text.substring(char_count2 +\n                             diff_text.length);\n        break;\n      case DIFF_EQUAL:\n        if (diff_text.length <= 2 * this.Patch_Margin &&\n            patchDiffLength && diffs.length != x + 1) {\n          // Small equality inside a patch.\n          patch.diffs[patchDiffLength++] = diffs[x];\n          patch.length1 += diff_text.length;\n          patch.length2 += diff_text.length;\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\n          // Time for a new patch.\n          if (patchDiffLength) {\n            this.patch_addContext_(patch, prepatch_text);\n            patches.push(patch);\n            patch = new diff_match_patch.patch_obj();\n            patchDiffLength = 0;\n            // Unlike Unidiff, our patch lists have a rolling context.\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\n            // Update prepatch text & pos to reflect the application of the\n            // just completed patch.\n            prepatch_text = postpatch_text;\n            char_count1 = char_count2;\n          }\n        }\n        break;\n    }\n\n    // Update the current character count.\n    if (diff_type !== DIFF_INSERT) {\n      char_count1 += diff_text.length;\n    }\n    if (diff_type !== DIFF_DELETE) {\n      char_count2 += diff_text.length;\n    }\n  }\n  // Pick up the leftover patch if not empty.\n  if (patchDiffLength) {\n    this.patch_addContext_(patch, prepatch_text);\n    patches.push(patch);\n  }\n\n  return patches;\n};\n\n\n/**\n * Given an array of patches, return another array that is identical.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n */\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\n  // Making deep copies is hard in JavaScript.\n  var patchesCopy = [];\n  for (var x = 0; x < patches.length; x++) {\n    var patch = patches[x];\n    var patchCopy = new diff_match_patch.patch_obj();\n    patchCopy.diffs = [];\n    for (var y = 0; y < patch.diffs.length; y++) {\n      patchCopy.diffs[y] = patch.diffs[y].slice();\n    }\n    patchCopy.start1 = patch.start1;\n    patchCopy.start2 = patch.start2;\n    patchCopy.length1 = patch.length1;\n    patchCopy.length2 = patch.length2;\n    patchesCopy[x] = patchCopy;\n  }\n  return patchesCopy;\n};\n\n\n/**\n * Merge a set of patches onto the text.  Return a patched text, as well\n * as a list of true/false values indicating which patches were applied.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n * @param {string} text Old text.\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\n *      new text and an array of boolean values.\n */\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\n  if (patches.length == 0) {\n    return [text, []];\n  }\n\n  // Deep copy the patches so that no changes are made to originals.\n  patches = this.patch_deepCopy(patches);\n\n  var nullPadding = this.patch_addPadding(patches);\n  text = nullPadding + text + nullPadding;\n\n  this.patch_splitMax(patches);\n  // delta keeps track of the offset between the expected and actual location\n  // of the previous patch.  If there are patches expected at positions 10 and\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\n  // has an effective expected position of 22.\n  var delta = 0;\n  var results = [];\n  for (var x = 0; x < patches.length; x++) {\n    var expected_loc = patches[x].start2 + delta;\n    var text1 = this.diff_text1(patches[x].diffs);\n    var start_loc;\n    var end_loc = -1;\n    if (text1.length > this.Match_MaxBits) {\n      // patch_splitMax will only provide an oversized pattern in the case of\n      // a monster delete.\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\n                                  expected_loc);\n      if (start_loc != -1) {\n        end_loc = this.match_main(text,\n            text1.substring(text1.length - this.Match_MaxBits),\n            expected_loc + text1.length - this.Match_MaxBits);\n        if (end_loc == -1 || start_loc >= end_loc) {\n          // Can't find valid trailing context.  Drop this patch.\n          start_loc = -1;\n        }\n      }\n    } else {\n      start_loc = this.match_main(text, text1, expected_loc);\n    }\n    if (start_loc == -1) {\n      // No match found.  :(\n      results[x] = false;\n      // Subtract the delta for this failed patch from subsequent patches.\n      delta -= patches[x].length2 - patches[x].length1;\n    } else {\n      // Found a match.  :)\n      results[x] = true;\n      delta = start_loc - expected_loc;\n      var text2;\n      if (end_loc == -1) {\n        text2 = text.substring(start_loc, start_loc + text1.length);\n      } else {\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\n      }\n      if (text1 == text2) {\n        // Perfect match, just shove the replacement text in.\n        text = text.substring(0, start_loc) +\n               this.diff_text2(patches[x].diffs) +\n               text.substring(start_loc + text1.length);\n      } else {\n        // Imperfect match.  Run a diff to get a framework of equivalent\n        // indices.\n        var diffs = this.diff_main(text1, text2, false);\n        if (text1.length > this.Match_MaxBits &&\n            this.diff_levenshtein(diffs) / text1.length >\n            this.Patch_DeleteThreshold) {\n          // The end points match, but the content is unacceptably bad.\n          results[x] = false;\n        } else {\n          this.diff_cleanupSemanticLossless(diffs);\n          var index1 = 0;\n          var index2;\n          for (var y = 0; y < patches[x].diffs.length; y++) {\n            var mod = patches[x].diffs[y];\n            if (mod[0] !== DIFF_EQUAL) {\n              index2 = this.diff_xIndex(diffs, index1);\n            }\n            if (mod[0] === DIFF_INSERT) {  // Insertion\n              text = text.substring(0, start_loc + index2) + mod[1] +\n                     text.substring(start_loc + index2);\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\n              text = text.substring(0, start_loc + index2) +\n                     text.substring(start_loc + this.diff_xIndex(diffs,\n                         index1 + mod[1].length));\n            }\n            if (mod[0] !== DIFF_DELETE) {\n              index1 += mod[1].length;\n            }\n          }\n        }\n      }\n    }\n  }\n  // Strip the padding off.\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\n  return [text, results];\n};\n\n\n/**\n * Add some padding on text start and end so that edges can match something.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n * @return {string} The padding string added to each side.\n */\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\n  var paddingLength = this.Patch_Margin;\n  var nullPadding = '';\n  for (var x = 1; x <= paddingLength; x++) {\n    nullPadding += String.fromCharCode(x);\n  }\n\n  // Bump all the patches forward.\n  for (var x = 0; x < patches.length; x++) {\n    patches[x].start1 += paddingLength;\n    patches[x].start2 += paddingLength;\n  }\n\n  // Add some padding on start of first diff.\n  var patch = patches[0];\n  var diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\n    patch.start1 -= paddingLength;  // Should be 0.\n    patch.start2 -= paddingLength;  // Should be 0.\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[0][1].length) {\n    // Grow first equality.\n    var extraLength = paddingLength - diffs[0][1].length;\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\n    patch.start1 -= extraLength;\n    patch.start2 -= extraLength;\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  // Add some padding on end of last diff.\n  patch = patches[patches.length - 1];\n  diffs = patch.diffs;\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\n    // Add nullPadding equality.\n    diffs.push([DIFF_EQUAL, nullPadding]);\n    patch.length1 += paddingLength;\n    patch.length2 += paddingLength;\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\n    // Grow last equality.\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\n    patch.length1 += extraLength;\n    patch.length2 += extraLength;\n  }\n\n  return nullPadding;\n};\n\n\n/**\n * Look through the patches and break up any which are longer than the maximum\n * limit of the match algorithm.\n * Intended to be called only from within patch_apply.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n */\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\n  var patch_size = this.Match_MaxBits;\n  for (var x = 0; x < patches.length; x++) {\n    if (patches[x].length1 > patch_size) {\n      var bigpatch = patches[x];\n      // Remove the big old patch.\n      patches.splice(x--, 1);\n      var start1 = bigpatch.start1;\n      var start2 = bigpatch.start2;\n      var precontext = '';\n      while (bigpatch.diffs.length !== 0) {\n        // Create one of several smaller patches.\n        var patch = new diff_match_patch.patch_obj();\n        var empty = true;\n        patch.start1 = start1 - precontext.length;\n        patch.start2 = start2 - precontext.length;\n        if (precontext !== '') {\n          patch.length1 = patch.length2 = precontext.length;\n          patch.diffs.push([DIFF_EQUAL, precontext]);\n        }\n        while (bigpatch.diffs.length !== 0 &&\n               patch.length1 < patch_size - this.Patch_Margin) {\n          var diff_type = bigpatch.diffs[0][0];\n          var diff_text = bigpatch.diffs[0][1];\n          if (diff_type === DIFF_INSERT) {\n            // Insertions are harmless.\n            patch.length2 += diff_text.length;\n            start2 += diff_text.length;\n            patch.diffs.push(bigpatch.diffs.shift());\n            empty = false;\n          } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\n                     patch.diffs[0][0] == DIFF_EQUAL &&\n                     diff_text.length > 2 * patch_size) {\n            // This is a large deletion.  Let it pass in one chunk.\n            patch.length1 += diff_text.length;\n            start1 += diff_text.length;\n            empty = false;\n            patch.diffs.push([diff_type, diff_text]);\n            bigpatch.diffs.shift();\n          } else {\n            // Deletion or equality.  Only take as much as we can stomach.\n            diff_text = diff_text.substring(0,\n                patch_size - patch.length1 - this.Patch_Margin);\n            patch.length1 += diff_text.length;\n            start1 += diff_text.length;\n            if (diff_type === DIFF_EQUAL) {\n              patch.length2 += diff_text.length;\n              start2 += diff_text.length;\n            } else {\n              empty = false;\n            }\n            patch.diffs.push([diff_type, diff_text]);\n            if (diff_text == bigpatch.diffs[0][1]) {\n              bigpatch.diffs.shift();\n            } else {\n              bigpatch.diffs[0][1] =\n                  bigpatch.diffs[0][1].substring(diff_text.length);\n            }\n          }\n        }\n        // Compute the head context for the next patch.\n        precontext = this.diff_text2(patch.diffs);\n        precontext =\n            precontext.substring(precontext.length - this.Patch_Margin);\n        // Append the end context for this patch.\n        var postcontext = this.diff_text1(bigpatch.diffs)\n                              .substring(0, this.Patch_Margin);\n        if (postcontext !== '') {\n          patch.length1 += postcontext.length;\n          patch.length2 += postcontext.length;\n          if (patch.diffs.length !== 0 &&\n              patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\n            patch.diffs[patch.diffs.length - 1][1] += postcontext;\n          } else {\n            patch.diffs.push([DIFF_EQUAL, postcontext]);\n          }\n        }\n        if (!empty) {\n          patches.splice(++x, 0, patch);\n        }\n      }\n    }\n  }\n};\n\n\n/**\n * Take a list of patches and return a textual representation.\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of patch objects.\n * @return {string} Text representation of patches.\n */\ndiff_match_patch.prototype.patch_toText = function(patches) {\n  var text = [];\n  for (var x = 0; x < patches.length; x++) {\n    text[x] = patches[x];\n  }\n  return text.join('');\n};\n\n\n/**\n * Parse a textual representation of patches and return a list of patch objects.\n * @param {string} textline Text representation of patches.\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of patch objects.\n * @throws {!Error} If invalid input.\n */\ndiff_match_patch.prototype.patch_fromText = function(textline) {\n  var patches = [];\n  if (!textline) {\n    return patches;\n  }\n  var text = textline.split('\\n');\n  var textPointer = 0;\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\n  while (textPointer < text.length) {\n    var m = text[textPointer].match(patchHeader);\n    if (!m) {\n      throw new Error('Invalid patch string: ' + text[textPointer]);\n    }\n    var patch = new diff_match_patch.patch_obj();\n    patches.push(patch);\n    patch.start1 = parseInt(m[1], 10);\n    if (m[2] === '') {\n      patch.start1--;\n      patch.length1 = 1;\n    } else if (m[2] == '0') {\n      patch.length1 = 0;\n    } else {\n      patch.start1--;\n      patch.length1 = parseInt(m[2], 10);\n    }\n\n    patch.start2 = parseInt(m[3], 10);\n    if (m[4] === '') {\n      patch.start2--;\n      patch.length2 = 1;\n    } else if (m[4] == '0') {\n      patch.length2 = 0;\n    } else {\n      patch.start2--;\n      patch.length2 = parseInt(m[4], 10);\n    }\n    textPointer++;\n\n    while (textPointer < text.length) {\n      var sign = text[textPointer].charAt(0);\n      try {\n        var line = decodeURI(text[textPointer].substring(1));\n      } catch (ex) {\n        // Malformed URI sequence.\n        throw new Error('Illegal escape in patch_fromText: ' + line);\n      }\n      if (sign == '-') {\n        // Deletion.\n        patch.diffs.push([DIFF_DELETE, line]);\n      } else if (sign == '+') {\n        // Insertion.\n        patch.diffs.push([DIFF_INSERT, line]);\n      } else if (sign == ' ') {\n        // Minor equality.\n        patch.diffs.push([DIFF_EQUAL, line]);\n      } else if (sign == '@') {\n        // Start of next patch.\n        break;\n      } else if (sign === '') {\n        // Blank line?  Whatever.\n      } else {\n        // WTF?\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\n      }\n      textPointer++;\n    }\n  }\n  return patches;\n};\n\n\n/**\n * Class representing one patch operation.\n * @constructor\n */\ndiff_match_patch.patch_obj = function() {\n  /** @type {!Array.<!diff_match_patch.Diff>} */\n  this.diffs = [];\n  /** @type {?number} */\n  this.start1 = null;\n  /** @type {?number} */\n  this.start2 = null;\n  /** @type {number} */\n  this.length1 = 0;\n  /** @type {number} */\n  this.length2 = 0;\n};\n\n\n/**\n * Emmulate GNU diff's format.\n * Header: @@ -382,8 +481,9 @@\n * Indicies are printed as 1-based, not 0-based.\n * @return {string} The GNU diff string.\n */\ndiff_match_patch.patch_obj.prototype.toString = function() {\n  var coords1, coords2;\n  if (this.length1 === 0) {\n    coords1 = this.start1 + ',0';\n  } else if (this.length1 == 1) {\n    coords1 = this.start1 + 1;\n  } else {\n    coords1 = (this.start1 + 1) + ',' + this.length1;\n  }\n  if (this.length2 === 0) {\n    coords2 = this.start2 + ',0';\n  } else if (this.length2 == 1) {\n    coords2 = this.start2 + 1;\n  } else {\n    coords2 = (this.start2 + 1) + ',' + this.length2;\n  }\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\n  var op;\n  // Escape the body of the patch with %xx notation.\n  for (var x = 0; x < this.diffs.length; x++) {\n    switch (this.diffs[x][0]) {\n      case DIFF_INSERT:\n        op = '+';\n        break;\n      case DIFF_DELETE:\n        op = '-';\n        break;\n      case DIFF_EQUAL:\n        op = ' ';\n        break;\n    }\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\n  }\n  return text.join('').replace(/%20/g, ' ');\n};\n\n\n// Export these global variables so that they survive Google's JS compiler.\n// In a browser, 'this' will be 'window'.\n// In node.js 'this' will be a global object.\nthis['diff_match_patch'] = diff_match_patch;\nthis['DIFF_DELETE'] = DIFF_DELETE;\nthis['DIFF_INSERT'] = DIFF_INSERT;\nthis['DIFF_EQUAL'] = DIFF_EQUAL;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/public/external/diff_match_patch_uncompressed.js\n ** module id = 5\n ** module chunks = 0\n **/","var Pipe = function Pipe(name) {\n  this.name = name;\n  this.filters = [];\n};\n\nPipe.prototype.process = function(input) {\n  if (!this.processor) {\n    throw new Error('add this pipe to a processor before using it');\n  }\n  var debug = this.debug;\n  var length = this.filters.length;\n  var context = input;\n  for (var index = 0; index < length; index++) {\n    var filter = this.filters[index];\n    if (debug) {\n      this.log('filter: ' + filter.filterName);\n    }\n    filter(context);\n    if (typeof context === 'object' && context.exiting) {\n      context.exiting = false;\n      break;\n    }\n  }\n  if (!context.next && this.resultCheck) {\n    this.resultCheck(context);\n  }\n};\n\nPipe.prototype.log = function(msg) {\n  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);\n};\n\nPipe.prototype.append = function() {\n  this.filters.push.apply(this.filters, arguments);\n  return this;\n};\n\nPipe.prototype.prepend = function() {\n  this.filters.unshift.apply(this.filters, arguments);\n  return this;\n};\n\nPipe.prototype.indexOf = function(filterName) {\n  if (!filterName) {\n    throw new Error('a filter name is required');\n  }\n  for (var index = 0; index < this.filters.length; index++) {\n    var filter = this.filters[index];\n    if (filter.filterName === filterName) {\n      return index;\n    }\n  }\n  throw new Error('filter not found: ' + filterName);\n};\n\nPipe.prototype.list = function() {\n  var names = [];\n  for (var index = 0; index < this.filters.length; index++) {\n    var filter = this.filters[index];\n    names.push(filter.filterName);\n  }\n  return names;\n};\n\nPipe.prototype.after = function(filterName) {\n  var index = this.indexOf(filterName);\n  var params = Array.prototype.slice.call(arguments, 1);\n  if (!params.length) {\n    throw new Error('a filter is required');\n  }\n  params.unshift(index + 1, 0);\n  Array.prototype.splice.apply(this.filters, params);\n  return this;\n};\n\nPipe.prototype.before = function(filterName) {\n  var index = this.indexOf(filterName);\n  var params = Array.prototype.slice.call(arguments, 1);\n  if (!params.length) {\n    throw new Error('a filter is required');\n  }\n  params.unshift(index, 0);\n  Array.prototype.splice.apply(this.filters, params);\n  return this;\n};\n\nPipe.prototype.clear = function() {\n  this.filters.length = 0;\n  return this;\n};\n\nPipe.prototype.shouldHaveResult = function(should) {\n  if (should === false) {\n    this.resultCheck = null;\n    return;\n  }\n  if (this.resultCheck) {\n    return;\n  }\n  var pipe = this;\n  this.resultCheck = function(context) {\n    if (!context.hasResult) {\n      console.log(context);\n      var error = new Error(pipe.name + ' failed');\n      error.noResult = true;\n      throw error;\n    }\n  };\n  return this;\n};\n\nexports.Pipe = Pipe;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/pipe.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * # Stor\n *\n * A store enhancer which triggers change/update settings based on external events.\n *\n * TODO: checkout compatibity after upgrading redux, https://github.com/reactjs/redux/pull/1702\n */\n\nimport stringify from 'json-stringify-safe'\nimport objectPath from 'object-path'\nimport { DiffPatcher } from 'jsondiffpatch/src/diffpatcher'\n\nconst diffpatcher = new DiffPatcher()\n\nconst INIT = '@@redux-sync/INIT'\nconst SYNC = '@@redux-sync/SYNC'\n\nconst defaultOptions = {\n  // exclude: [], // - allows to specify patterns for excludes\n  // include: [], // - allows to specify patterns for includes\n  root: null,  // - optional: entry pointer what/where it should be synchronized !\n  id: '*'      // - optional: used to differentiate if multiple sync stores are used!\n}\n\n// TODO: remove reference on unsubscribe/disconnect to avoid memory leak\nconst connections = Object.create(null)\n\nexport default function syncStore (customOptions) {\n\n  if (customOptions && typeof customOptions === 'string') {\n    customOptions = { root: customOptions }\n  }\n\n  const options = {...defaultOptions}\n\n  if (customOptions) {\n    Object.assign(options, customOptions)\n  }\n\n  const env = {\n    isIframe: window !== window.parent\n  }\n\n  return (createStore) => (reducer, initialState) => {\n\n    const store = createStore(reducer, initialState)\n\n    // get initial state after creation\n    const creationState = store.getState()\n\n    if (env.isIframe) {\n      const creationPatch = diffpatcher.diff({}, creationState)\n      sendMessage(options, window.parent, { type: INIT, state: creationState }, creationPatch)\n    }\n\n    // listen to internal dispatches to communicate (~ middlware)\n    const dispatch = (action) => {\n\n      const stateBefore = store.getState()\n      const result = store.dispatch(action)\n      const stateAfter = store.getState()\n\n      if (env.isIframe) {\n        const patch = diffpatcher.diff(stateBefore, stateAfter)\n        sendMessage(options, window.parent, action, patch)\n      } else {\n        const patch = diffpatcher.diff(\n          objectPath.get(stateBefore, options.root),\n          objectPath.get(stateAfter, options.root)\n        )\n        if (patch) {\n          const connection = connections[options.id]\n          connection && sendMessage(options, connection, action, patch)\n        }\n      }\n\n      return result\n    }\n\n    // listen to external messages\n    window.addEventListener('message', ({ data, origin, source }) => {\n      // filter by prefix\n      if (typeof data === 'string' && data.indexOf('redux-sync:') === 0) {\n\n        const { id, trigger, patch } = JSON.parse(data.replace('redux-sync:', ''))\n\n        if (trigger.type === INIT) {\n          connections[id] = source\n        }\n\n        store.dispatch({ type: SYNC, trigger, patch })\n      }\n    })\n\n    // wrap reducer to patch data\n    store.replaceReducer((state = creationState, action) => {\n\n      if (action.type === SYNC) {\n        // TODO: handle/merge complex types of 'immutables'\n        // TODO: use selective approach for decoupling references (e.g. based on {...state})\n        state = JSON.parse(stringify(state))\n        diffpatcher.patch(objectPath.get(state, options.root), action.patch)\n        return state\n      }\n\n      return reducer(state, action)\n    })\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n\n/**\n* Send triggering action and the complete state.\n* TODO: currently restricted to postMessages || could be extend to other channels (e.g. websocket)\n*\n* @param  {[type]} customOptions [description]\n* @param  {[type]} state         [description]\n* @return {[type]}               [description]\n*/\nfunction sendMessage (options, scope, action, patch) {\n  scope && scope.postMessage('redux-sync:' + stringify({\n    id: options.id,\n    trigger: action,\n    patch\n  }), '*')\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/store.js\n **/","exports = module.exports = stringify\nexports.getSerialize = serializer\n\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\n}\n\nfunction serializer(replacer, cycleReplacer) {\n  var stack = [], keys = []\n\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\n    if (stack[0] === value) return \"[Circular ~]\"\n    return \"[Circular ~.\" + keys.slice(0, stack.indexOf(value)).join(\".\") + \"]\"\n  }\n\n  return function(key, value) {\n    if (stack.length > 0) {\n      var thisPos = stack.indexOf(this)\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\n    }\n    else stack.push(value)\n\n    return replacer == null ? value : replacer.call(this, key, value)\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/json-stringify-safe/stringify.js\n ** module id = 8\n ** module chunks = 0\n **/","var map = {\n\t\"./diff_match_patch_uncompressed\": 5,\n\t\"./diff_match_patch_uncompressed.js\": 5\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 9;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/public/external ^\\.\\/.*$\n ** module id = 9\n ** module chunks = 0\n **/","// use as 2nd parameter for JSON.parse to revive Date instances\nmodule.exports = function dateReviver(key, value) {\n  var parts;\n  if (typeof value === 'string') {\n    parts = /^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d*))?(Z|([+\\-])(\\d{2}):(\\d{2}))$/.exec(value);\n    if (parts) {\n      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\n    }\n  }\n  return value;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/date-reviver.js\n ** module id = 10\n ** module chunks = 0\n **/","var Processor = require('./processor').Processor;\nvar Pipe = require('./pipe').Pipe;\nvar DiffContext = require('./contexts/diff').DiffContext;\nvar PatchContext = require('./contexts/patch').PatchContext;\nvar ReverseContext = require('./contexts/reverse').ReverseContext;\n\nvar trivial = require('./filters/trivial');\nvar nested = require('./filters/nested');\nvar arrays = require('./filters/arrays');\nvar dates = require('./filters/dates');\nvar texts = require('./filters/texts');\n\nvar DiffPatcher = function DiffPatcher(options) {\n  this.processor = new Processor(options);\n  this.processor.pipe(new Pipe('diff').append(\n    nested.collectChildrenDiffFilter,\n    trivial.diffFilter,\n    dates.diffFilter,\n    texts.diffFilter,\n    nested.objectsDiffFilter,\n    arrays.diffFilter\n  ).shouldHaveResult());\n  this.processor.pipe(new Pipe('patch').append(\n    nested.collectChildrenPatchFilter,\n    arrays.collectChildrenPatchFilter,\n    trivial.patchFilter,\n    texts.patchFilter,\n    nested.patchFilter,\n    arrays.patchFilter\n  ).shouldHaveResult());\n  this.processor.pipe(new Pipe('reverse').append(\n    nested.collectChildrenReverseFilter,\n    arrays.collectChildrenReverseFilter,\n    trivial.reverseFilter,\n    texts.reverseFilter,\n    nested.reverseFilter,\n    arrays.reverseFilter\n  ).shouldHaveResult());\n};\n\nDiffPatcher.prototype.options = function() {\n  return this.processor.options.apply(this.processor, arguments);\n};\n\nDiffPatcher.prototype.diff = function(left, right) {\n  return this.processor.process(new DiffContext(left, right));\n};\n\nDiffPatcher.prototype.patch = function(left, delta) {\n  return this.processor.process(new PatchContext(left, delta));\n};\n\nDiffPatcher.prototype.reverse = function(delta) {\n  return this.processor.process(new ReverseContext(delta));\n};\n\nDiffPatcher.prototype.unpatch = function(right, delta) {\n  return this.patch(right, this.reverse(delta));\n};\n\nexports.DiffPatcher = DiffPatcher;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/diffpatcher.js\n ** module id = 11\n ** module chunks = 0\n **/","var DiffContext = require('../contexts/diff').DiffContext;\nvar PatchContext = require('../contexts/patch').PatchContext;\nvar ReverseContext = require('../contexts/reverse').ReverseContext;\n\nvar lcs = require('./lcs');\n\nvar ARRAY_MOVE = 3;\n\nvar isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nvar arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?\n  function(array, item) {\n    return array.indexOf(item);\n  } : function(array, item) {\n    var length = array.length;\n    for (var i = 0; i < length; i++) {\n      if (array[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\n  for (var index1 = 0; index1 < len1; index1++) {\n    var val1 = array1[index1];\n    for (var index2 = 0; index2 < len2; index2++) {\n      var val2 = array2[index2];\n      if (val1 === val2) {\n        return true;\n      }\n    }\n  }\n}\n\nfunction matchItems(array1, array2, index1, index2, context) {\n  var value1 = array1[index1];\n  var value2 = array2[index2];\n  if (value1 === value2) {\n    return true;\n  }\n  if (typeof value1 !== 'object' || typeof value2 !== 'object') {\n    return false;\n  }\n  var objectHash = context.objectHash;\n  if (!objectHash) {\n    // no way to match objects was provided, try match by position\n    return context.matchByPosition && index1 === index2;\n  }\n  var hash1;\n  var hash2;\n  if (typeof index1 === 'number') {\n    context.hashCache1 = context.hashCache1 || [];\n    hash1 = context.hashCache1[index1];\n    if (typeof hash1 === 'undefined') {\n      context.hashCache1[index1] = hash1 = objectHash(value1, index1);\n    }\n  } else {\n    hash1 = objectHash(value1);\n  }\n  if (typeof hash1 === 'undefined') {\n    return false;\n  }\n  if (typeof index2 === 'number') {\n    context.hashCache2 = context.hashCache2 || [];\n    hash2 = context.hashCache2[index2];\n    if (typeof hash2 === 'undefined') {\n      context.hashCache2[index2] = hash2 = objectHash(value2, index2);\n    }\n  } else {\n    hash2 = objectHash(value2);\n  }\n  if (typeof hash2 === 'undefined') {\n    return false;\n  }\n  return hash1 === hash2;\n}\n\nvar diffFilter = function arraysDiffFilter(context) {\n  if (!context.leftIsArray) {\n    return;\n  }\n\n  var matchContext = {\n    objectHash: context.options && context.options.objectHash,\n    matchByPosition: context.options && context.options.matchByPosition\n  };\n  var commonHead = 0;\n  var commonTail = 0;\n  var index;\n  var index1;\n  var index2;\n  var array1 = context.left;\n  var array2 = context.right;\n  var len1 = array1.length;\n  var len2 = array2.length;\n\n  var child;\n\n  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&\n    typeof matchContext.matchByPosition !== 'boolean') {\n    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\n  }\n\n  // separate common head\n  while (commonHead < len1 && commonHead < len2 &&\n    matchItems(array1, array2, commonHead, commonHead, matchContext)) {\n    index = commonHead;\n    child = new DiffContext(context.left[index], context.right[index]);\n    context.push(child, index);\n    commonHead++;\n  }\n  // separate common tail\n  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&\n    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\n    index1 = len1 - 1 - commonTail;\n    index2 = len2 - 1 - commonTail;\n    child = new DiffContext(context.left[index1], context.right[index2]);\n    context.push(child, index2);\n    commonTail++;\n  }\n  var result;\n  if (commonHead + commonTail === len1) {\n    if (len1 === len2) {\n      // arrays are identical\n      context.setResult(undefined).exit();\n      return;\n    }\n    // trivial case, a block (1 or more consecutive items) was added\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len2 - commonTail; index++) {\n      result[index] = [array2[index]];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  if (commonHead + commonTail === len2) {\n    // trivial case, a block (1 or more consecutive items) was removed\n    result = result || {\n      _t: 'a'\n    };\n    for (index = commonHead; index < len1 - commonTail; index++) {\n      result['_' + index] = [array1[index], 0, 0];\n    }\n    context.setResult(result).exit();\n    return;\n  }\n  // reset hash cache\n  delete matchContext.hashCache1;\n  delete matchContext.hashCache2;\n\n  // diff is not trivial, find the LCS (Longest Common Subsequence)\n  var trimmed1 = array1.slice(commonHead, len1 - commonTail);\n  var trimmed2 = array2.slice(commonHead, len2 - commonTail);\n  var seq = lcs.get(\n    trimmed1, trimmed2,\n    matchItems,\n    matchContext\n  );\n  var removedItems = [];\n  result = result || {\n    _t: 'a'\n  };\n  for (index = commonHead; index < len1 - commonTail; index++) {\n    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {\n      // removed\n      result['_' + index] = [array1[index], 0, 0];\n      removedItems.push(index);\n    }\n  }\n\n  var detectMove = true;\n  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {\n    detectMove = false;\n  }\n  var includeValueOnMove = false;\n  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {\n    includeValueOnMove = true;\n  }\n\n  var removedItemsLength = removedItems.length;\n  for (index = commonHead; index < len2 - commonTail; index++) {\n    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);\n    if (indexOnArray2 < 0) {\n      // added, try to match with a removed item and register as position move\n      var isMove = false;\n      if (detectMove && removedItemsLength > 0) {\n        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\n          index1 = removedItems[removeItemIndex1];\n          if (matchItems(trimmed1, trimmed2, index1 - commonHead,\n            index - commonHead, matchContext)) {\n            // store position move as: [originalValue, newPosition, ARRAY_MOVE]\n            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);\n            if (!includeValueOnMove) {\n              // don't include moved value on diff, to save bytes\n              result['_' + index1][0] = '';\n            }\n\n            index2 = index;\n            child = new DiffContext(context.left[index1], context.right[index2]);\n            context.push(child, index2);\n            removedItems.splice(removeItemIndex1, 1);\n            isMove = true;\n            break;\n          }\n        }\n      }\n      if (!isMove) {\n        // added\n        result[index] = [array2[index]];\n      }\n    } else {\n      // match, do inner diff\n      index1 = seq.indices1[indexOnArray2] + commonHead;\n      index2 = seq.indices2[indexOnArray2] + commonHead;\n      child = new DiffContext(context.left[index1], context.right[index2]);\n      context.push(child, index2);\n    }\n  }\n\n  context.setResult(result).exit();\n\n};\ndiffFilter.filterName = 'arrays';\n\nvar compare = {\n  numerically: function(a, b) {\n    return a - b;\n  },\n  numericallyBy: function(name) {\n    return function(a, b) {\n      return a[name] - b[name];\n    };\n  }\n};\n\nvar patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var index, index1;\n\n  var delta = context.delta;\n  var array = context.left;\n\n  // first, separate removals, insertions and modifications\n  var toRemove = [];\n  var toInsert = [];\n  var toModify = [];\n  for (index in delta) {\n    if (index !== '_t') {\n      if (index[0] === '_') {\n        // removed item from original array\n        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {\n          toRemove.push(parseInt(index.slice(1), 10));\n        } else {\n          throw new Error('only removal or move can be applied at original array indices' +\n            ', invalid diff type: ' + delta[index][2]);\n        }\n      } else {\n        if (delta[index].length === 1) {\n          // added item at new array\n          toInsert.push({\n            index: parseInt(index, 10),\n            value: delta[index][0]\n          });\n        } else {\n          // modified item at new array\n          toModify.push({\n            index: parseInt(index, 10),\n            delta: delta[index]\n          });\n        }\n      }\n    }\n  }\n\n  // remove items, in reverse order to avoid sawing our own floor\n  toRemove = toRemove.sort(compare.numerically);\n  for (index = toRemove.length - 1; index >= 0; index--) {\n    index1 = toRemove[index];\n    var indexDiff = delta['_' + index1];\n    var removedValue = array.splice(index1, 1)[0];\n    if (indexDiff[2] === ARRAY_MOVE) {\n      // reinsert later\n      toInsert.push({\n        index: indexDiff[1],\n        value: removedValue\n      });\n    }\n  }\n\n  // insert items, in reverse order to avoid moving our own floor\n  toInsert = toInsert.sort(compare.numericallyBy('index'));\n  var toInsertLength = toInsert.length;\n  for (index = 0; index < toInsertLength; index++) {\n    var insertion = toInsert[index];\n    array.splice(insertion.index, 0, insertion.value);\n  }\n\n  // apply modifications\n  var toModifyLength = toModify.length;\n  var child;\n  if (toModifyLength > 0) {\n    for (index = 0; index < toModifyLength; index++) {\n      var modification = toModify[index];\n      child = new PatchContext(context.left[modification.index], modification.delta);\n      context.push(child, modification.index);\n    }\n  }\n\n  if (!context.children) {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.exit();\n};\npatchFilter.filterName = 'arrays';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    context.left[child.childName] = child.result;\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\n\nvar reverseFilter = function arraysReverseFilter(context) {\n  if (!context.nested) {\n    if (context.delta[2] === ARRAY_MOVE) {\n      context.newName = '_' + context.delta[1];\n      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();\n    }\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    if (name === '_t') {\n      continue;\n    }\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'arrays';\n\nvar reverseArrayDeltaIndex = function(delta, index, itemDelta) {\n  if (typeof index === 'string' && index[0] === '_') {\n    return parseInt(index.substr(1), 10);\n  } else if (isArray(itemDelta) && itemDelta[2] === 0) {\n    return '_' + index;\n  }\n\n  var reverseIndex = +index;\n  for (var deltaIndex in delta) {\n    var deltaItem = delta[deltaIndex];\n    if (isArray(deltaItem)) {\n      if (deltaItem[2] === ARRAY_MOVE) {\n        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);\n        var moveToIndex = deltaItem[1];\n        if (moveToIndex === +index) {\n          return moveFromIndex;\n        }\n        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\n          reverseIndex++;\n        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {\n          reverseIndex--;\n        }\n      } else if (deltaItem[2] === 0) {\n        var deleteIndex = parseInt(deltaIndex.substr(1), 10);\n        if (deleteIndex <= reverseIndex) {\n          reverseIndex++;\n        }\n      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {\n        reverseIndex--;\n      }\n    }\n  }\n\n  return reverseIndex;\n};\n\nvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t !== 'a') {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var delta = {\n    _t: 'a'\n  };\n\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    var name = child.newName;\n    if (typeof name === 'undefined') {\n      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);\n    }\n    if (delta[name] !== child.result) {\n      delta[name] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n};\ncollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.collectChildrenPatchFilter = collectChildrenPatchFilter;\nexports.reverseFilter = reverseFilter;\nexports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/arrays.js\n ** module id = 12\n ** module chunks = 0\n **/","var diffFilter = function datesDiffFilter(context) {\n  if (context.left instanceof Date) {\n    if (context.right instanceof Date) {\n      if (context.left.getTime() !== context.right.getTime()) {\n        context.setResult([context.left, context.right]);\n      } else {\n        context.setResult(undefined);\n      }\n    } else {\n      context.setResult([context.left, context.right]);\n    }\n    context.exit();\n  } else if (context.right instanceof Date) {\n    context.setResult([context.left, context.right]).exit();\n  }\n};\ndiffFilter.filterName = 'dates';\n\nexports.diffFilter = diffFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/dates.js\n ** module id = 13\n ** module chunks = 0\n **/","/*\n\nLCS implementation that supports arrays or strings\n\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\n\n*/\n\nvar defaultMatch = function(array1, array2, index1, index2) {\n  return array1[index1] === array2[index2];\n};\n\nvar lengthMatrix = function(array1, array2, match, context) {\n  var len1 = array1.length;\n  var len2 = array2.length;\n  var x, y;\n\n  // initialize empty matrix of len1+1 x len2+1\n  var matrix = [len1 + 1];\n  for (x = 0; x < len1 + 1; x++) {\n    matrix[x] = [len2 + 1];\n    for (y = 0; y < len2 + 1; y++) {\n      matrix[x][y] = 0;\n    }\n  }\n  matrix.match = match;\n  // save sequence lengths for each coordinate\n  for (x = 1; x < len1 + 1; x++) {\n    for (y = 1; y < len2 + 1; y++) {\n      if (match(array1, array2, x - 1, y - 1, context)) {\n        matrix[x][y] = matrix[x - 1][y - 1] + 1;\n      } else {\n        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\n      }\n    }\n  }\n  return matrix;\n};\n\nvar backtrack = function(matrix, array1, array2, index1, index2, context) {\n  if (index1 === 0 || index2 === 0) {\n    return {\n      sequence: [],\n      indices1: [],\n      indices2: []\n    };\n  }\n\n  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {\n    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);\n    subsequence.sequence.push(array1[index1 - 1]);\n    subsequence.indices1.push(index1 - 1);\n    subsequence.indices2.push(index2 - 1);\n    return subsequence;\n  }\n\n  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {\n    return backtrack(matrix, array1, array2, index1, index2 - 1, context);\n  } else {\n    return backtrack(matrix, array1, array2, index1 - 1, index2, context);\n  }\n};\n\nvar get = function(array1, array2, match, context) {\n  context = context || {};\n  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);\n  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);\n  if (typeof array1 === 'string' && typeof array2 === 'string') {\n    result.sequence = result.sequence.join('');\n  }\n  return result;\n};\n\nexports.get = get;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/lcs.js\n ** module id = 14\n ** module chunks = 0\n **/","var DiffContext = require('../contexts/diff').DiffContext;\nvar PatchContext = require('../contexts/patch').PatchContext;\nvar ReverseContext = require('../contexts/reverse').ReverseContext;\n\nvar collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var result = context.result;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (typeof child.result === 'undefined') {\n      continue;\n    }\n    result = result || {};\n    result[child.childName] = child.result;\n  }\n  if (result && context.leftIsArray) {\n    result._t = 'a';\n  }\n  context.setResult(result).exit();\n};\ncollectChildrenDiffFilter.filterName = 'collectChildren';\n\nvar objectsDiffFilter = function objectsDiffFilter(context) {\n  if (context.leftIsArray || context.leftType !== 'object') {\n    return;\n  }\n\n  var name, child, propertyFilter = context.options.propertyFilter;\n  for (name in context.left) {\n    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    child = new DiffContext(context.left[name], context.right[name]);\n    context.push(child, name);\n  }\n  for (name in context.right) {\n    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {\n      continue;\n    }\n    if (propertyFilter && !propertyFilter(name, context)) {\n      continue;\n    }\n    if (typeof context.left[name] === 'undefined') {\n      child = new DiffContext(undefined, context.right[name]);\n      context.push(child, name);\n    }\n  }\n\n  if (!context.children || context.children.length === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  context.exit();\n};\nobjectsDiffFilter.filterName = 'objects';\n\nvar patchFilter = function nestedPatchFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    child = new PatchContext(context.left[name], context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\npatchFilter.filterName = 'objects';\n\nvar collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {\n      delete context.left[child.childName];\n    } else if (context.left[child.childName] !== child.result) {\n      context.left[child.childName] = child.result;\n    }\n  }\n  context.setResult(context.left).exit();\n};\ncollectChildrenPatchFilter.filterName = 'collectChildren';\n\nvar reverseFilter = function nestedReverseFilter(context) {\n  if (!context.nested) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var name, child;\n  for (name in context.delta) {\n    child = new ReverseContext(context.delta[name]);\n    context.push(child, name);\n  }\n  context.exit();\n};\nreverseFilter.filterName = 'objects';\n\nvar collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {\n  if (!context || !context.children) {\n    return;\n  }\n  if (context.delta._t) {\n    return;\n  }\n  var length = context.children.length;\n  var child;\n  var delta = {};\n  for (var index = 0; index < length; index++) {\n    child = context.children[index];\n    if (delta[child.childName] !== child.result) {\n      delta[child.childName] = child.result;\n    }\n  }\n  context.setResult(delta).exit();\n};\ncollectChildrenReverseFilter.filterName = 'collectChildren';\n\nexports.collectChildrenDiffFilter = collectChildrenDiffFilter;\nexports.objectsDiffFilter = objectsDiffFilter;\nexports.patchFilter = patchFilter;\nexports.collectChildrenPatchFilter = collectChildrenPatchFilter;\nexports.reverseFilter = reverseFilter;\nexports.collectChildrenReverseFilter = collectChildrenReverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/nested.js\n ** module id = 15\n ** module chunks = 0\n **/","/* global diff_match_patch */\nvar TEXT_DIFF = 2;\nvar DEFAULT_MIN_LENGTH = 60;\nvar cachedDiffPatch = null;\n\nvar getDiffMatchPatch = function(required) {\n  /*jshint camelcase: false */\n\n  if (!cachedDiffPatch) {\n    var instance;\n    if (typeof diff_match_patch !== 'undefined') {\n      // already loaded, probably a browser\n      instance = typeof diff_match_patch === 'function' ?\n        new diff_match_patch() : new diff_match_patch.diff_match_patch();\n    } else if (typeof require === 'function') {\n      try {\n        var dmpModuleName = 'diff_match_patch_uncompressed';\n        var dmp = require('../../public/external/' + dmpModuleName);\n        instance = new dmp.diff_match_patch();\n      } catch (err) {\n        instance = null;\n      }\n    }\n    if (!instance) {\n      if (!required) {\n        return null;\n      }\n      var error = new Error('text diff_match_patch library not found');\n      error.diff_match_patch_not_found = true;\n      throw error;\n    }\n    cachedDiffPatch = {\n      diff: function(txt1, txt2) {\n        return instance.patch_toText(instance.patch_make(txt1, txt2));\n      },\n      patch: function(txt1, patch) {\n        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);\n        for (var i = 0; i < results[1].length; i++) {\n          if (!results[1][i]) {\n            var error = new Error('text patch failed');\n            error.textPatchFailed = true;\n          }\n        }\n        return results[0];\n      }\n    };\n  }\n  return cachedDiffPatch;\n};\n\nvar diffFilter = function textsDiffFilter(context) {\n  if (context.leftType !== 'string') {\n    return;\n  }\n  var minLength = (context.options && context.options.textDiff &&\n    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;\n  if (context.left.length < minLength ||\n    context.right.length < minLength) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  // large text, try to use a text-diff algorithm\n  var diffMatchPatch = getDiffMatchPatch();\n  if (!diffMatchPatch) {\n    // diff-match-patch library not available, fallback to regular string replace\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  var diff = diffMatchPatch.diff;\n  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();\n};\ndiffFilter.filterName = 'texts';\n\nvar patchFilter = function textsPatchFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-patch algorithm\n  var patch = getDiffMatchPatch(true).patch;\n  context.setResult(patch(context.left, context.delta[0])).exit();\n};\npatchFilter.filterName = 'texts';\n\nvar textDeltaReverse = function(delta) {\n  var i, l, lines, line, lineTmp, header = null,\n    headerRegex = /^@@ +\\-(\\d+),(\\d+) +\\+(\\d+),(\\d+) +@@$/,\n    lineHeader, lineAdd, lineRemove;\n  lines = delta.split('\\n');\n  for (i = 0, l = lines.length; i < l; i++) {\n    line = lines[i];\n    var lineStart = line.slice(0, 1);\n    if (lineStart === '@') {\n      header = headerRegex.exec(line);\n      lineHeader = i;\n      lineAdd = null;\n      lineRemove = null;\n\n      // fix header\n      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';\n    } else if (lineStart === '+') {\n      lineAdd = i;\n      lines[i] = '-' + lines[i].slice(1);\n      if (lines[i - 1].slice(0, 1) === '+') {\n        // swap lines to keep default order (-+)\n        lineTmp = lines[i];\n        lines[i] = lines[i - 1];\n        lines[i - 1] = lineTmp;\n      }\n    } else if (lineStart === '-') {\n      lineRemove = i;\n      lines[i] = '+' + lines[i].slice(1);\n    }\n  }\n  return lines.join('\\n');\n};\n\nvar reverseFilter = function textsReverseFilter(context) {\n  if (context.nested) {\n    return;\n  }\n  if (context.delta[2] !== TEXT_DIFF) {\n    return;\n  }\n\n  // text-diff, use a text-diff algorithm\n  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();\n};\nreverseFilter.filterName = 'texts';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.reverseFilter = reverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/texts.js\n ** module id = 16\n ** module chunks = 0\n **/","var isArray = (typeof Array.isArray === 'function') ?\n  // use native function\n  Array.isArray :\n  // use instanceof operator\n  function(a) {\n    return a instanceof Array;\n  };\n\nvar diffFilter = function trivialMatchesDiffFilter(context) {\n  if (context.left === context.right) {\n    context.setResult(undefined).exit();\n    return;\n  }\n  if (typeof context.left === 'undefined') {\n    if (typeof context.right === 'function') {\n      throw new Error('functions are not supported');\n    }\n    context.setResult([context.right]).exit();\n    return;\n  }\n  if (typeof context.right === 'undefined') {\n    context.setResult([context.left, 0, 0]).exit();\n    return;\n  }\n  if (typeof context.left === 'function' || typeof context.right === 'function') {\n    throw new Error('functions are not supported');\n  }\n  context.leftType = context.left === null ? 'null' : typeof context.left;\n  context.rightType = context.right === null ? 'null' : typeof context.right;\n  if (context.leftType !== context.rightType) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'boolean' || context.leftType === 'number') {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n  if (context.leftType === 'object') {\n    context.leftIsArray = isArray(context.left);\n  }\n  if (context.rightType === 'object') {\n    context.rightIsArray = isArray(context.right);\n  }\n  if (context.leftIsArray !== context.rightIsArray) {\n    context.setResult([context.left, context.right]).exit();\n    return;\n  }\n};\ndiffFilter.filterName = 'trivial';\n\nvar patchFilter = function trivialMatchesPatchFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.left).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult(context.delta[0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult(context.delta[1]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult(undefined).exit();\n    return;\n  }\n};\npatchFilter.filterName = 'trivial';\n\nvar reverseFilter = function trivialReferseFilter(context) {\n  if (typeof context.delta === 'undefined') {\n    context.setResult(context.delta).exit();\n    return;\n  }\n  context.nested = !isArray(context.delta);\n  if (context.nested) {\n    return;\n  }\n  if (context.delta.length === 1) {\n    context.setResult([context.delta[0], 0, 0]).exit();\n    return;\n  }\n  if (context.delta.length === 2) {\n    context.setResult([context.delta[1], context.delta[0]]).exit();\n    return;\n  }\n  if (context.delta.length === 3 && context.delta[2] === 0) {\n    context.setResult([context.delta[0]]).exit();\n    return;\n  }\n};\nreverseFilter.filterName = 'trivial';\n\nexports.diffFilter = diffFilter;\nexports.patchFilter = patchFilter;\nexports.reverseFilter = reverseFilter;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/filters/trivial.js\n ** module id = 17\n ** module chunks = 0\n **/","\nvar Processor = function Processor(options){\n  this.selfOptions = options || {};\n  this.pipes = {};\n};\n\nProcessor.prototype.options = function(options) {\n  if (options) {\n    this.selfOptions = options;\n  }\n  return this.selfOptions;\n};\n\nProcessor.prototype.pipe = function(name, pipe) {\n  if (typeof name === 'string') {\n    if (typeof pipe === 'undefined') {\n      return this.pipes[name];\n    } else {\n      this.pipes[name] = pipe;\n    }\n  }\n  if (name && name.name) {\n    pipe = name;\n    if (pipe.processor === this) { return pipe; }\n    this.pipes[pipe.name] = pipe;\n  }\n  pipe.processor = this;\n  return pipe;\n};\n\nProcessor.prototype.process = function(input, pipe) {\n  var context = input;\n  context.options = this.options();\n  var nextPipe = pipe || input.pipe || 'default';\n  var lastPipe, lastContext;\n  while (nextPipe) {\n    if (typeof context.nextAfterChildren !== 'undefined') {\n      // children processed and coming back to parent\n      context.next = context.nextAfterChildren;\n      context.nextAfterChildren = null;\n    }\n\n    if (typeof nextPipe === 'string') {\n      nextPipe = this.pipe(nextPipe);\n    }\n    nextPipe.process(context);\n    lastContext = context;\n    lastPipe = nextPipe;\n    nextPipe = null;\n    if (context) {\n      if (context.next) {\n        context = context.next;\n        nextPipe = lastContext.nextPipe || context.pipe || lastPipe;\n      }\n    }\n  }\n  return context.hasResult ? context.result : undefined;\n};\n\nexports.Processor = Processor;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/jsondiffpatch/src/processor.js\n ** module id = 18\n ** module chunks = 0\n **/","(function (root, factory){\n  'use strict';\n\n  /*istanbul ignore next:cant test*/\n  if (typeof module === 'object' && typeof module.exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else {\n    // Browser globals\n    root.objectPath = factory();\n  }\n})(this, function(){\n  'use strict';\n\n  var\n    toStr = Object.prototype.toString,\n    _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  function isEmpty(value){\n    if (!value) {\n      return true;\n    }\n    if (isArray(value) && value.length === 0) {\n        return true;\n    } else if (!isString(value)) {\n        for (var i in value) {\n            if (_hasOwnProperty.call(value, i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n  }\n\n  function toString(type){\n    return toStr.call(type);\n  }\n\n  function isNumber(value){\n    return typeof value === 'number' || toString(value) === \"[object Number]\";\n  }\n\n  function isString(obj){\n    return typeof obj === 'string' || toString(obj) === \"[object String]\";\n  }\n\n  function isObject(obj){\n    return typeof obj === 'object' && toString(obj) === \"[object Object]\";\n  }\n\n  function isArray(obj){\n    return typeof obj === 'object' && typeof obj.length === 'number' && toString(obj) === '[object Array]';\n  }\n\n  function isBoolean(obj){\n    return typeof obj === 'boolean' || toString(obj) === '[object Boolean]';\n  }\n\n  function getKey(key){\n    var intKey = parseInt(key);\n    if (intKey.toString() === key) {\n      return intKey;\n    }\n    return key;\n  }\n\n  function set(obj, path, value, doNotReplace){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isString(path)) {\n      return set(obj, path.split('.').map(getKey), value, doNotReplace);\n    }\n    var currentPath = path[0];\n\n    if (path.length === 1) {\n      var oldVal = obj[currentPath];\n      if (oldVal === void 0 || !doNotReplace) {\n        obj[currentPath] = value;\n      }\n      return oldVal;\n    }\n\n    if (obj[currentPath] === void 0) {\n      //check if we assume an array\n      if(isNumber(path[1])) {\n        obj[currentPath] = [];\n      } else {\n        obj[currentPath] = {};\n      }\n    }\n\n    return set(obj[currentPath], path.slice(1), value, doNotReplace);\n  }\n\n  function del(obj, path) {\n    if (isNumber(path)) {\n      path = [path];\n    }\n\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if(isString(path)) {\n      return del(obj, path.split('.'));\n    }\n\n    var currentPath = getKey(path[0]);\n    var oldVal = obj[currentPath];\n\n    if(path.length === 1) {\n      if (oldVal !== void 0) {\n        if (isArray(obj)) {\n          obj.splice(currentPath, 1);\n        } else {\n          delete obj[currentPath];\n        }\n      }\n    } else {\n      if (obj[currentPath] !== void 0) {\n        return del(obj[currentPath], path.slice(1));\n      }\n    }\n\n    return obj;\n  }\n\n  var objectPath = function(obj) {\n    return Object.keys(objectPath).reduce(function(proxy, prop) {\n      if (typeof objectPath[prop] === 'function') {\n        proxy[prop] = objectPath[prop].bind(objectPath, obj);\n      }\n\n      return proxy;\n    }, {});\n  };\n\n  objectPath.has = function (obj, path) {\n    if (isEmpty(obj)) {\n      return false;\n    }\n\n    if (isNumber(path)) {\n      path = [path];\n    } else if (isString(path)) {\n      path = path.split('.');\n    }\n\n    if (isEmpty(path) || path.length === 0) {\n      return false;\n    }\n\n    for (var i = 0; i < path.length; i++) {\n      var j = path[i];\n      if ((isObject(obj) || isArray(obj)) && _hasOwnProperty.call(obj, j)) {\n        obj = obj[j];\n      } else {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  objectPath.ensureExists = function (obj, path, value){\n    return set(obj, path, value, true);\n  };\n\n  objectPath.set = function (obj, path, value, doNotReplace){\n    return set(obj, path, value, doNotReplace);\n  };\n\n  objectPath.insert = function (obj, path, value, at){\n    var arr = objectPath.get(obj, path);\n    at = ~~at;\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n    arr.splice(at, 0, value);\n  };\n\n  objectPath.empty = function(obj, path) {\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return void 0;\n    }\n\n    var value, i;\n    if (!(value = objectPath.get(obj, path))) {\n      return obj;\n    }\n\n    if (isString(value)) {\n      return objectPath.set(obj, path, '');\n    } else if (isBoolean(value)) {\n      return objectPath.set(obj, path, false);\n    } else if (isNumber(value)) {\n      return objectPath.set(obj, path, 0);\n    } else if (isArray(value)) {\n      value.length = 0;\n    } else if (isObject(value)) {\n      for (i in value) {\n        if (_hasOwnProperty.call(value, i)) {\n          delete value[i];\n        }\n      }\n    } else {\n      return objectPath.set(obj, path, null);\n    }\n  };\n\n  objectPath.push = function (obj, path /*, values */){\n    var arr = objectPath.get(obj, path);\n    if (!isArray(arr)) {\n      arr = [];\n      objectPath.set(obj, path, arr);\n    }\n\n    arr.push.apply(arr, Array.prototype.slice.call(arguments, 2));\n  };\n\n  objectPath.coalesce = function (obj, paths, defaultValue) {\n    var value;\n\n    for (var i = 0, len = paths.length; i < len; i++) {\n      if ((value = objectPath.get(obj, paths[i])) !== void 0) {\n        return value;\n      }\n    }\n\n    return defaultValue;\n  };\n\n  objectPath.get = function (obj, path, defaultValue){\n    if (isNumber(path)) {\n      path = [path];\n    }\n    if (isEmpty(path)) {\n      return obj;\n    }\n    if (isEmpty(obj)) {\n      return defaultValue;\n    }\n    if (isString(path)) {\n      return objectPath.get(obj, path.split('.'), defaultValue);\n    }\n\n    var currentPath = getKey(path[0]);\n\n    if (path.length === 1) {\n      if (obj[currentPath] === void 0) {\n        return defaultValue;\n      }\n      return obj[currentPath];\n    }\n\n    return objectPath.get(obj[currentPath], path.slice(1), defaultValue);\n  };\n\n  objectPath.del = function(obj, path) {\n    return del(obj, path);\n  };\n\n  return objectPath;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/object-path/index.js\n ** module id = 19\n ** module chunks = 0\n **/"],"sourceRoot":""}